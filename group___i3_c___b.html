<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZG Flexible Software Package Documentation: I3C (r_i3c_b)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZG Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___i3_c___b.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">I3C (r_i3c_b)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___c_o_n_n_e_c_t_i_v_i_t_y___m_o_d_u_l_e_s.html">Connectivity</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa9ce3fda0950ce2aaa0cd8cf51fb5f95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gaa9ce3fda0950ce2aaa0cd8cf51fb5f95">R_I3C_B_Open</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___i3_c___a_p_i.html#structi3c__cfg__t">i3c_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gaa9ce3fda0950ce2aaa0cd8cf51fb5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1dcb91a0152da9a6676ee27d305dceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gae1dcb91a0152da9a6676ee27d305dceb">R_I3C_B_Enable</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gae1dcb91a0152da9a6676ee27d305dceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b0af405a9ca84c45aab74bd1c696c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga07b0af405a9ca84c45aab74bd1c696c2">R_I3C_B_DeviceCfgSet</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___i3_c___a_p_i.html#structi3c__device__cfg__t">i3c_device_cfg_t</a> const *const p_device_cfg)</td></tr>
<tr class="separator:ga07b0af405a9ca84c45aab74bd1c696c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9517cc752212a1423f0153c4330943b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga9517cc752212a1423f0153c4330943b4">R_I3C_B_MasterDeviceTableSet</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, uint32_t device_index, <a class="el" href="group___i3_c___a_p_i.html#structi3c__device__table__cfg__t">i3c_device_table_cfg_t</a> const *const p_device_table_cfg)</td></tr>
<tr class="separator:ga9517cc752212a1423f0153c4330943b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4178234c4311d227a6fb8844e1e3a49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga4178234c4311d227a6fb8844e1e3a49e">R_I3C_B_SlaveStatusSet</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___i3_c___a_p_i.html#structi3c__device__status__t">i3c_device_status_t</a> status)</td></tr>
<tr class="separator:ga4178234c4311d227a6fb8844e1e3a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a3f7414a893b9c2b9135523c8f6d950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga2a3f7414a893b9c2b9135523c8f6d950">R_I3C_B_DeviceSelect</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, uint32_t device_index, uint32_t bitrate_mode)</td></tr>
<tr class="separator:ga2a3f7414a893b9c2b9135523c8f6d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014e6425d49e19f05d24fd345a785589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga014e6425d49e19f05d24fd345a785589">R_I3C_B_DynamicAddressAssignmentStart</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___i3_c___a_p_i.html#ga6ebef50cdf52650f03e1b449325779fc">i3c_address_assignment_mode_t</a> address_assignment_mode, uint32_t starting_device_index, uint32_t device_count)</td></tr>
<tr class="separator:ga014e6425d49e19f05d24fd345a785589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ef6e15732ea09c5ad2fb19095cae4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga36ef6e15732ea09c5ad2fb19095cae4e">R_I3C_B_CommandSend</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___i3_c___a_p_i.html#structi3c__command__descriptor__t">i3c_command_descriptor_t</a> const *const p_command_descriptor)</td></tr>
<tr class="separator:ga36ef6e15732ea09c5ad2fb19095cae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf661fd87ee8c33efd8801d59997d4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gadf661fd87ee8c33efd8801d59997d4a1">R_I3C_B_Write</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, uint8_t const *const p_data, uint32_t length, bool restart)</td></tr>
<tr class="separator:gadf661fd87ee8c33efd8801d59997d4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69047e20f165f6e44fea97f3fec69399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga69047e20f165f6e44fea97f3fec69399">R_I3C_B_Read</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_data, uint32_t length, bool restart)</td></tr>
<tr class="separator:ga69047e20f165f6e44fea97f3fec69399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4af888ebc4c210feea2a149fd4cfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga0b4af888ebc4c210feea2a149fd4cfc1">R_I3C_B_IbiWrite</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___i3_c___a_p_i.html#ga81ac58196d67e74a0a3702c3e760ede7">i3c_ibi_type_t</a> ibi_type, uint8_t const *const p_data, uint32_t length)</td></tr>
<tr class="separator:ga0b4af888ebc4c210feea2a149fd4cfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad786c546168aabcc04099f73a540af29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gad786c546168aabcc04099f73a540af29">R_I3C_B_IbiRead</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_data, uint32_t length)</td></tr>
<tr class="separator:gad786c546168aabcc04099f73a540af29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd84cf1baec319b18540a857545ab51b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gadd84cf1baec319b18540a857545ab51b">R_I3C_B_Close</a> (<a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:gadd84cf1baec319b18540a857545ab51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the I3C peripheral on RZ MPU. This module implements the <a class="el" href="group___i3_c___a_p_i.html">I3C Interface</a>. </p>
<h1><a class="anchor" id="r-i3c_b-overview"></a>
Overview</h1>
<p>I3C is a communication protocol defined by MIPI that aims to improve on I2C by increasing the maximum transfer rate, as well as providing other features like "In-band Interrupts", "Dynamic Address Assignment", and a set of standard "Common Command Codes".</p>
<h2><a class="anchor" id="r-i3c_b-features"></a>
Features</h2>
<p><a class="anchor" id="um_i3c_master_entdaa"></a><a class="anchor" id="um_i3c_master_write"></a><a class="anchor" id="um_i3c_master_read"></a><a class="anchor" id="um_i3c_master_i2c_legacy"></a><a class="anchor" id="um_i3c_slave_entdaa"></a><a class="anchor" id="um_i3c_slave_read"></a><a class="anchor" id="um_i3c_slave_write"></a><a class="anchor" id="um_master_common_command_codes"></a><a class="anchor" id="um_slave_common_command_codes"></a><a class="anchor" id="um_i3c_ibi_read"></a><a class="anchor" id="um_i3c_ibi_read_request"></a><a class="anchor" id="um_i3c_ibi_read_no_payload"></a><a class="anchor" id="um_i3c_ibi_nack"></a><a class="anchor" id="um_i3c_ibi_notify_nack_disabled"></a><a class="anchor" id="um_i3c_ibi_hot_join"></a><a class="anchor" id="um_i3c_ibi_hot_join_nack"></a><a class="anchor" id="um_secondary_master_mode"></a></p><ul>
<li>I3C Master Mode</li>
<li>I3C Slave Mode</li>
<li>Dynamic Address Assignment (ENTDAA/SETDASA)</li>
<li>SDR Read/Write transfers</li>
<li>I2C Legacy Read/Write transfers</li>
<li>In-Band Interrupts (Interrupt Requests, Hot-Join Requests)</li>
<li>Common Command Codes</li>
<li>Clock Stalling</li>
<li>Timeout Detection</li>
</ul>
<h1>Master Mode</h1>
<p>On an I3C bus, only one device may operate in master mode at a time. The current master is responsible for initiating I2C Legacy transfers, SDR transfers, Common Command Codes, and handling IBIs (Interrupt Requests, Hot-Join Requests). In order to perform these operations, the driver has an internal device table that is used for storing configuration information for each device on the bus (See <a class="el" href="group___i3_c___a_p_i.html#structi3c__device__table__cfg__t">i3c_device_table_cfg_t</a>). Each entry in the device table contains the static or dynamic address of the device, and IBI permissions for accepting or rejecting IBI requests from the device. The device table has a limited number of entries as well as one extended device entry that only contains the static or dynamic address of a device (See below).</p>
<div class="image">
<object type="image/svg+xml" data="r_i3c_device_table.svg">r_i3c_device_table.svg</object>
<div class="caption">
Master Device Table</div></div>
<p> In order to initiate I2C Legacy transfers, SDR transfers, or Common Command Codes, the master must select a device entry from the device table using <a class="el" href="group___i3_c___a_p_i.html#a1e24e768130b9ea12f10743ff3143fa7">i3c_api_t::deviceSelect</a>. Once a device has been selected, all subsequent operations will be directed to the selected device until a new device is selected using <a class="el" href="group___i3_c___a_p_i.html#a1e24e768130b9ea12f10743ff3143fa7">i3c_api_t::deviceSelect</a>.</p>
<p>The master may also receive IBI requests that are initiated by slave devices on the bus. If there is a payload, then the driver will write the data into a buffer that is provided by the application by calling <a class="el" href="group___i3_c___a_p_i.html#a3b2a78b5f633df2cfb07133ad5ae9c91">i3c_api_t::ibiRead</a>. If the application has not provided an IBI buffer prior to receiving an IBI, then the it will get a callback requesting an IBI buffer. Once the IBI is completed, the application will be notified by a callback.</p>
<dl class="section note"><dt>Note</dt><dd>1. Even though there are only a limited number of device table entries and one extended device table entry, the application can operate on more devices by maintaining its own list of devices and updating the extended device entry as needed. Note however that devices defined in the extended device table entry will not be able to initiate IBI requests.</dd></dl>
<h2>Main Master</h2>
<p>The main master is responsible for configuring the dynamic address of all devices on the bus. The driver initiates this procedure by calling <a class="el" href="group___i3_c___a_p_i.html#ae57d3fa9fa4a966a5c8cac38b0ea0660">i3c_api_t::dynamicAddressAssignmentStart</a>. Before starting address assignment, the application must configure the device table using <a class="el" href="group___i3_c___a_p_i.html#ac790719d9f6a87b3458bfab85ffda558">i3c_api_t::masterDeviceTableSet</a>.</p>
<h3>Enter Dynamic Address Assignment (ENTDAA):</h3>
<p>The application initiates the ENTDAA operation by calling <a class="el" href="group___i3_c___a_p_i.html#ae57d3fa9fa4a966a5c8cac38b0ea0660">i3c_api_t::dynamicAddressAssignmentStart</a> with a starting index into the master device table and a count specifying the number of devices to configure. The master starts by sending the ENTDAA command. Every I3C device on the bus that has not already been initialized will acknowledge the command and attempt to write its Provisional ID, DCR, and BCR registers. The device with the smallest value in these registers will win arbitration and be assigned with the first dynamic address defined in the master device table. The master will then increment the index and repeat the process by assigning the dynamic address to the next device. The process continues until the specified number of devices have been initialized or until there are no more devices to configure.</p>
<dl class="section note"><dt>Note</dt><dd>1. The IBI payload setting will automatically be updated in the master device table based on the BCR setting that was read during ENTDAA. </dd>
<dd>
2. After each device successfully writes its Provisional ID, DCR, and BCR registers, the application will get a callback that will provide the value of the registers. </dd>
<dd>
3. If the starting index is set to the extended device entry, then the device count must be set to 1. </dd>
<dd>
4. The main master assigns its own dynamic address with <a class="el" href="group___i3_c___a_p_i.html#ad1a5e82be324c969d8397e687eb66c08">i3c_api_t::deviceCfgSet</a>.</dd></dl>
<h3>Set Dynamic Address from Static Address (SETDASA):</h3>
<p>The application initiates the SETDASA operation by calling <a class="el" href="group___i3_c___a_p_i.html#ae57d3fa9fa4a966a5c8cac38b0ea0660">i3c_api_t::dynamicAddressAssignmentStart</a> with an index into the master device table. The master sends the SETDASA command to the static address defined in the given device table entry, and then assigns the associated dynamic address.</p>
<dl class="section note"><dt>Note</dt><dd>1. Set the count to 0 when using SETDASA.</dd></dl>
<h1>Slave Mode</h1>
<p>In slave mode, the device configures its static address, Provisional ID, BCR, and DCR registers using <a class="el" href="group___i3_c___a_p_i.html#ad1a5e82be324c969d8397e687eb66c08">i3c_api_t::deviceCfgSet</a>, and then waits for the master to initiate communication. Prior to being assigned a dynamic address, the slave will operate as an I2C device using its static address. The application will receive a callback when the master assigns it a dynamic address, after which point, the slave will operate as an I3C device until it receives the RSTDAA command.</p>
<p>Depending on the capabilities defined in its BCR register, the slave may also initiate IBI Interrupt Requests, and Hot-Join Requests using <a class="el" href="group___i3_c___a_p_i.html#a78bf93c241804116b1a4efc18e6c1028">i3c_api_t::ibiWrite</a></p>
<h1><a class="anchor" id="r-i3c_b-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_i3c_master_bitrate"></a> <h2>Build Time Configurations for r_i3c_b</h2>
The following build time configurations are defined in fsp_cfg/r_i3c_b_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Unaligned Buffer Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Unaligned buffer support may be optionally disabled for improved performance. </td></tr>
<tr>
<td>Master Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>If only slave mode is required, disable master support to decrease code size. </td></tr>
<tr>
<td>Slave Support</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>If only master mode is required, disable slave support to decrease code size. </td></tr>
<tr>
<td>Error Recovery Procedure</td><td>Support Error Recovery of I3C mode</td><td>Support Error Recovery of I3C mode </td><td>Error Recovery of I3C mode </td></tr>
</table>
 <h2>Configurations for Connectivity &gt; I3C (r_i3c_b)</h2>
This module can be added to the Stacks tab via New Stack &gt; Connectivity &gt; I3C (r_i3c_b).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Bitrate Settings &gt; Standard Mode &gt; Open-Drain &gt; Logic High Period (ns)</td><td>Must be an integer greater than 0.</td><td>167 </td><td>The Logic High period of SCL during Standard Mode Open Drain transfers. </td></tr>
<tr>
<td>Bitrate Settings &gt; Standard Mode &gt; Open-Drain &gt; Frequency</td><td>Must be an integer greater than 0.</td><td>1000000 </td><td>The Frequency of SCL during Standard Mode Open Drain transfers. </td></tr>
<tr>
<td>Bitrate Settings &gt; Standard Mode &gt; Push-Pull &gt; Logic High Period (ns)</td><td>The Logic High Period must be greater than or equal to 24 Nanoseconds.</td><td>167 </td><td>The Logic High period of SCL during Standard Mode Push Pull transfers. </td></tr>
<tr>
<td>Bitrate Settings &gt; Standard Mode &gt; Push-Pull &gt; Frequency</td><td>Push-Pull frequency must be greater than or equal to 10000 Hz.</td><td>3400000 </td><td>The Frequency of SCL during Standard Mode Push-Pull transfers. </td></tr>
<tr>
<td>Bitrate Settings &gt; Extended Mode &gt; Open-Drain &gt; Logic High Period (ns)</td><td>Must be an integer greater than 0.</td><td>167 </td><td>The Logic High period of SCL during Extended Mode Open Drain transfers. </td></tr>
<tr>
<td>Bitrate Settings &gt; Extended Mode &gt; Open-Drain &gt; Frequency</td><td>Must be an integer greater than 0.</td><td>1000000 </td><td>The Frequency of SCL during Extended Mode Open Drain transfers. </td></tr>
<tr>
<td>Bitrate Settings &gt; Extended Mode &gt; Push-Pull &gt; Logic High Period (ns)</td><td>The Logic High Period must be greater than or equal to 24 Nanoseconds.</td><td>167 </td><td>The Logic High period of SCL during Extended Mode Push Pull transfers. </td></tr>
<tr>
<td>Bitrate Settings &gt; Extended Mode &gt; Push-Pull &gt; Frequency</td><td>Push-Pull frequency must be greater than or equal to 10000 Hz.</td><td>3400000 </td><td>The Frequency of SCL during Extended Mode Push-Pull transfers. </td></tr>
<tr>
<td>Bitrate Settings &gt; Bus Timing &gt; Open Drain Rising Time (ns)</td><td>Rising time must be greater than or equal to 0 nanoseconds.</td><td>0 </td><td>The Open Drain rising time in nanoseconds. </td></tr>
<tr>
<td>Bitrate Settings &gt; Bus Timing &gt; Open Drain Falling Time (ns)</td><td>Falling time must be greater than or equal to 0 nanoseconds.</td><td>0 </td><td>The Open Drain falling time in nanoseconds. </td></tr>
<tr>
<td>Bitrate Settings &gt; Bus Timing &gt; Push-Pull Rising Time (ns)</td><td>Rising time must be greater than or equal to 0 nanoseconds.</td><td>0 </td><td>The Push-Pull rising time in nanoseconds. </td></tr>
<tr>
<td>Bitrate Settings &gt; Bus Timing &gt; Push-Pull Falling Time (ns)</td><td>Falling time must be greater than or equal to 0 nanoseconds.</td><td>0 </td><td>The Push-Pull rising time in nanoseconds. </td></tr>
<tr>
<td>Bitrate Settings &gt; Clock Stalling &gt; Address Assignment Phase</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable clock stalling during the Address Assignment Phase of ENTDAA. </td></tr>
<tr>
<td>Bitrate Settings &gt; Clock Stalling &gt; Transition Phase</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable clock stalling during the Transition Bit of a read transfer. </td></tr>
<tr>
<td>Bitrate Settings &gt; Clock Stalling &gt; Parity Phase</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable clock stalling during the Parity Bit of a write transfer. </td></tr>
<tr>
<td>Bitrate Settings &gt; Clock Stalling &gt; Ack Phase</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable clock stalling during the ACK phase of a transfer. </td></tr>
<tr>
<td>Bitrate Settings &gt; Clock Stalling &gt; Time (us)</td><td>Must be greater than or equal to 0.</td><td>0 </td><td>The amount of time to stall the clock during the Address Assignment Phase, Transition Phase, Parity Phase, and ACK Phase. </td></tr>
<tr>
<td>Master Mode &gt; ACK Hot-Join Requests</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, the I3C_B instance will ACK Hot-Join Requests and notify the application. </td></tr>
<tr>
<td>Master Mode &gt; Notify Rejected Hot-Join Requests.</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, the application will get a callback when an IBI Hot-Join Request is rejected. </td></tr>
<tr>
<td>Master Mode &gt; Notify Rejected Mastership Requests.</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, the application will get a callback when an IBI Mastership Request is rejected. </td></tr>
<tr>
<td>Master Mode &gt; Notify Rejected Interrupt Requests.</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, the application will get a callback when an IBI Interrupt Request is rejected. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; ENEC/DISEC &gt; In-Band Interrupts</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Configure whether the slave can issue IBI requests. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; ENEC/DISEC &gt; Hot-Join Requests</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Configure whether the slave can issue Hot-Join requests. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; ENTASn &gt; Activity State</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Activity State 0</li>
<li>
Activity State 1</li>
<li>
Activity State 2</li>
<li>
Activity State 3</li>
</ul>
</td><td>Activity State 0 </td><td>Configure the starting activity state of the slave. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; SETMWL/GETMWL &gt; Max Write Length</td><td>Write length must be in the range of [8, 65535].</td><td>65535 </td><td>Set the max write length. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; SETMRL/GETMRL &gt; Max Read Length</td><td>Read length must be in the range of [16, 65535].</td><td>65535 </td><td>Set the max read length. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; SETMRL/GETMRL &gt; Max IBI Payload Length</td><td>Read length must be in the range of [0, 255].</td><td>0 </td><td>Set the max IBI payload length, or set it to 0 for unlimited. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; GETMXDS &gt; Write Data Rate</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
FSCL_MAX</li>
<li>
8Mhz</li>
<li>
6Mhz</li>
<li>
4Mhz</li>
<li>
2Mhz</li>
</ul>
</td><td>2Mhz </td><td>Set the max write data rate. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; GETMXDS &gt; Read Data Rate</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
FSCL_MAX</li>
<li>
8Mhz</li>
<li>
6Mhz</li>
<li>
4Mhz</li>
<li>
2Mhz</li>
</ul>
</td><td>2Mhz </td><td>Set the max read data rate. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; GETMXDS &gt; Clock to Data Turnaround Time</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
8 Nanoseconds</li>
<li>
9 Nanoseconds</li>
<li>
10 Nanoseconds</li>
<li>
11 Nanoseconds</li>
<li>
12 Nanoseconds</li>
<li>
Greater than 12 Nanoseconds</li>
</ul>
</td><td>8 Nanoseconds </td><td>Set the clock to data turnaround time. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; GETMXDS &gt; Include Max Read Turnaround Time</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Configure whether the Max Read Turnaround time will be transmitted. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; GETMXDS &gt; Max Read Turnaround Time</td><td>Value must be in the range [0, 255].</td><td>0 </td><td>Set max read turnaround time. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; GETXTIME &gt; Frequency Byte</td><td>Value must be in the range [0, 255].</td><td>0 </td><td>Set the internal oscillator frequency in increments of 0.5 Mhz. </td></tr>
<tr>
<td>Slave Mode &gt; Command Response Info &gt; GETXTIME &gt; Inaccuracy Byte</td><td>Value must be in the range [0, 255].</td><td>0 </td><td>Set the oscillator inaccuracy byte in increments of 0.5% </td></tr>
<tr>
<td>Interrupts &gt; Interrupt Priority</td><td>Channel number must be a positive integer</td><td>10 </td><td>The interrupt priority of the RX, TX, RESPONSE, RCV_STATUS, and IBI ISRs. </td></tr>
<tr>
<td>Interrupts &gt; Error and Event Interrupt Priority</td><td>Channel number must be a positive integer</td><td>10 </td><td>The interrupt priority of the EEI ISR which is used to notify the application when an Internal Error, HDR Exit Pattern, or Timeout is detected. </td></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_i3c0 </td><td>Module name. </td></tr>
<tr>
<td>Callback</td><td>Name must be a valid C symbol</td><td>g_i3c0_callback </td><td>A user callback function must be provided. This will be called in order to notify the application of I3C_B events and provide status information. </td></tr>
<tr>
<td>Callback Context</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A pointer to additional application specific information that is provided to the callback. </td></tr>
<tr>
<td>Device Type</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Main Master</li>
<li>
Slave</li>
</ul>
</td><td>Slave </td><td>The role that the I3C_B instance will take on the I3C_B bus. </td></tr>
<tr>
<td>Bus Free Condition Detection Time (ns)</td><td>Must be greater than or equal to 38.4 nanoseconds.</td><td>38.4 </td><td>The minimum period occurring after a STOP and before a START. </td></tr>
<tr>
<td>Bus Available Condition Detection Time (us)</td><td>Must be greater than or equal to 1 microsecond.</td><td>1 </td><td>The minimum period occurring after the Bus Free Condition when Slaves can initiate IBI requests. </td></tr>
<tr>
<td>Bus Idle Condition Detection Time (us)</td><td>Must be greater than or equal to 1000 microseconds.</td><td>1000 </td><td>The minimum period occurring after the Bus Available Condition when Slaves can initiate Hot-Join requests. </td></tr>
<tr>
<td>Timeout Detection</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, the application will get a callback if SCL is stuck at a logic high or logic low level for more than 65535 cycles of the I3C_B source clock. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-i3c_b-clock-configuration"></a>
Clock Configuration</h2>
<p>The following settings are used to configure the timing of SCL.</p><ul>
<li>Frequency of TCLK</li>
<li>Standard Mode<ul>
<li>Open Drain High Period (T<sub>HIGH</sub>)</li>
<li>Open Drain Frequency</li>
<li>Push-Pull High Period (T<sub>HIGH</sub>)</li>
<li>Push-Pull Frequency</li>
</ul>
</li>
<li>Extended Mode<ul>
<li>Open Drain High Period (T<sub>HIGH</sub>)</li>
<li>Open Drain Frequency</li>
<li>Push-Pull High Period (T<sub>HIGH</sub>)</li>
<li>Push-Pull Frquency</li>
</ul>
</li>
<li><a class="el" href="group___i3_c___b.html#gac8fb0ec859c44282b8323eb13de6ad3c">i3c_b_bitrate_mode_t</a> (Set during <a class="el" href="group___i3_c___a_p_i.html#a1e24e768130b9ea12f10743ff3143fa7">i3c_api_t::deviceSelect</a>)</li>
</ul>
<p>The Standard and Extended Mode settings define two separate SCL configurations that can be selected at run-time using <a class="el" href="group___i3_c___a_p_i.html#a1e24e768130b9ea12f10743ff3143fa7">i3c_api_t::deviceSelect</a>.</p>
<p>In addition to selecting between the Standard and Extended Mode settings, the base SCL period can also be multiplied using the following options:</p><ul>
<li>I3C_B_BITRATE_MODE_I3C_SDR2_STDBR_X2: Multiple the base Standard Open Drain and Push-Pull period by 2.</li>
<li>I3C_B_BITRATE_MODE_I3C_SDR3_EXTBR_X2: Multiple the base Extended Open Drain and Push-Pull period by 2.</li>
<li>I3C_B_BITRATE_MODE_I3C_SDR4_EXTBR_X4: Multiple the base Extended Open Drain and Push-Pull period by 4.</li>
</ul>
<p>In order to get accurate frequency calculations, the Rising and Falling edges must be input into the calculation. These values will depend on the topology the I3C bus that will be different for every application.</p>
<dl class="section note"><dt>Note</dt><dd>1. The Standard and Extended Open Drain period settings define the period to use during legacy I2C transfers (Only use the following <a class="el" href="group___i3_c___b.html#gac8fb0ec859c44282b8323eb13de6ad3c">i3c_b_bitrate_mode_t</a> settings with I2C transfers: I3C_B_BITRATE_MODE_I2C_STDBR, I3C_B_BITRATE_MODE_I2C_EXTBR). </dd>
<dd>
2. T<sub>HIGH</sub> is defined in Figure 31 in the MIPI I3C Specification v1.0 and describes the Logic High period. </dd>
<dd>
3. Depending on the MPU, TCLK is derived from P4CLK.</dd></dl>
<h2><a class="anchor" id="r-i3c_b-pin-configuration"></a>
Pin Configuration</h2>
<p>The I3C peripheral module uses pins on the MPU to communicate to external devices. I/O pins must be selected and configured as required by the external device. An I3C channel would consist of two pins - SDA and SCL for data/address and clock respectively.</p>
<h1><a class="anchor" id="r-i3c_b-usage_notes"></a>
Usage Notes</h1>
<h2>Read and Write in Slave Mode</h2>
<p>In slave mode, calling read or write does not start a transfer. Instead, calling read or write will configure the driver to perform the next read or write transfer using the user provided buffer.</p>
<p>Provided that a transfer is not already in progress, <a class="el" href="group___i3_c___a_p_i.html#ad013ffb59c95539c84fe217b90d897ad">i3c_api_t::read</a> and <a class="el" href="group___i3_c___a_p_i.html#a0b27ccf4720531545b0c2e118032539b">i3c_api_t::write</a> can be called to update the internal buffers even if the transfer has not been completed yet. Both the read and write buffers can be configured at the same time in order to prepare the driver for when the master initiates a read or a write transfer.</p>
<p>If there is no space remaining in a user configured read buffer, the application will get a <a class="el" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca401943802babdddf23fdc32573c220d2">I3C_EVENT_READ_BUFFER_FULL</a> callback requesting for a new read buffer to be provided.</p>
<h2>Event Status</h2>
<p>When a write, read, ibiWrite, ibiRead or commandSend, operation is completed, the <a class="el" href="group___i3_c___a_p_i.html#a149831362decabc4676bd5e8265821dd">i3c_callback_args_t::event_status</a> should be checked. The event_status will provide information about the success or failure of the operation.</p>
<p>The following are possible statuses:</p><ul>
<li><a class="el" href="group___i3_c___b.html#ga66e705cb2af31c57eacd0492b2417145">I3C_B_EVENT_STATUS_SUCCESS</a></li>
<li><a class="el" href="group___i3_c___b.html#ga20332b13e43cafe1a0ee0dbc195d7467">I3C_B_EVENT_STATUS_PARITY</a></li>
<li><a class="el" href="group___i3_c___b.html#ga4c155a91650485e935a7d95b65bf6ea1">I3C_B_EVENT_STATUS_FRAME</a></li>
<li><a class="el" href="group___i3_c___b.html#gab4bffde187fcf342dfc6cabc1a7353d8">I3C_B_EVENT_STATUS_ADDRESS_HEADER</a></li>
<li><a class="el" href="group___i3_c___b.html#gaac076b32d443c844645e0d1e9a6d184e">I3C_B_EVENT_STATUS_NACK</a></li>
<li><a class="el" href="group___i3_c___b.html#ga103bea85dbeeb58f40d85e3b1bd00fae">I3C_B_EVENT_STATUS_OVERFLOW</a></li>
<li><a class="el" href="group___i3_c___b.html#gae15f0c28a3098b35b3eaf0456f1c4a5b">I3C_B_EVENT_STATUS_ABORTED_TO_MASTER</a></li>
<li><a class="el" href="group___i3_c___b.html#ga7aed8b3fb4cfd7004b8f785a8884f4ff">I3C_B_EVENT_STATUS_ABORTED</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In master mode, if the master issues a stop condition before the slave ends the transfer via the 'T' bit, the status will be <a class="el" href="group___i3_c___b.html#ga7aed8b3fb4cfd7004b8f785a8884f4ff">I3C_B_EVENT_STATUS_ABORTED</a>. </dd>
<dd>
In slave mode, if the master issues a stop condition before the slave ends the transfer via the 'T' bit, the status will be <a class="el" href="group___i3_c___b.html#gae15f0c28a3098b35b3eaf0456f1c4a5b">I3C_B_EVENT_STATUS_ABORTED_TO_MASTER</a>.</dd></dl>
<h2>Direct Get Common Command Codes in Slave Mode</h2>
<p>When an I3C slave receives a Command Code of type Direct Get, the response is automatically sent from the device Special Function Registers (SFR). The SFR contains information for each command code and can be configured during open (See <a class="el" href="group___i3_c___b.html#a0f2fd857b12b9284dddf430463764016">i3c_b_extended_cfg_t::slave_command_response_info</a>). This allows the slave to respond to Direct Get Command Codes much faster, and removes the burden of responding to these commands from the application.</p>
<p>The response to the GETSTATUS command can be configured at run-time using <a class="el" href="group___i3_c___a_p_i.html#a39518a413d0c9056e41d4da97ce3884e">i3c_api_t::slaveStatusSet</a>.</p>
<h2>Disabling Unaligned Buffer Support</h2>
<p>Support for performing read and write operations on unaligned buffers can be disabled in order to improve performance. When unaligned buffer support is disabled, all buffers passed to read, ibiRead, write, ibiWrite, and commandSend must be aligned to 4 bytes and the size of the buffers must be a multiple of 4 bytes.</p>
<p>In master mode, the value of the length passed to <a class="el" href="group___i3_c___a_p_i.html#ad013ffb59c95539c84fe217b90d897ad">i3c_api_t::read</a> and <a class="el" href="group___i3_c___a_p_i.html#a0b27ccf4720531545b0c2e118032539b">i3c_api_t::write</a> sets the total length of the operation in bytes. During the read or write operation, the driver may read or write to the last word of memory during the operation. This means that the allocated memory for the buffer passed to read and write needs to be a multiple of 4 bytes even though the transfer length is not a multiple of 4 bytes.</p>
<p>In slave mode, the length passed to <a class="el" href="group___i3_c___a_p_i.html#ad013ffb59c95539c84fe217b90d897ad">i3c_api_t::read</a> must be a multiple of 4 bytes. The length passed to <a class="el" href="group___i3_c___a_p_i.html#a0b27ccf4720531545b0c2e118032539b">i3c_api_t::write</a> sets the number of bytes that the slave will write. The size of the buffer passed to write still needs to be a multiple of 4 bytes.</p>
<h2>Max Data Speed Limitation</h2>
<p>In Slave Mode, it is highly recommended that BCR[0] be set to '1' in order to indicate to the master that the device doesn't support the max data speed. The master is then required to use the GETMXDS command to get the device specific data speed limitations.</p>
<p>This will allow the slave to specify its maximum supported data rate for read/write, and the maximum read turnaround time (See GETMXDS in the MIPI I3C Specification v1.0).</p>
<h2>Mixed Fast Bus</h2>
<p>The MIPI I3C Specification v1.0 defines a Mixed Fast Bus as a bus that has legacy I2C devices that all have a 50ns Spike Filter.</p>
<p>On Mixed Fast Buses, SCL has the following constraints during I3C SDR transfers:</p><ul>
<li>SCL High Period: t<sub>DIG_H_MIXED(MIN)</sub> to t<sub>DIG_H_MIXED(MAX)</sub></li>
<li>SCL Low Period: Up to t<sub>DIG_L(MAX)</sub></li>
</ul>
<p>In this case, configure the Extended Bitrate settings for I3C SDR transfers, and use the Standard Bitrate settings for I2C transfers.</p>
<dl class="section note"><dt>Note</dt><dd>1. See section 5.1.2.4 in the MIPI I3C Specification v1.0.</dd></dl>
<h2>Mixed Slow Bus</h2>
<p>The MIPI I3C Specification v1.0 defines a Mixed Slow Bus as a bus that has legacy I2C devices that do not have a 50ns Spike Filter.</p>
<p>In this case, the SCL frequency is limited to I2C Fast Mode or I2C Fast Mode Plus.</p>
<dl class="section note"><dt>Note</dt><dd>1. See section 5.1.2.4 in the MIPI I3C Specification v1.0.</dd></dl>
<h2><a class="anchor" id="r-i3c_b-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the I3C:</p>
<ul>
<li>The MIPI Reserved area and Vendor Extension area of Command Codes are not supported.</li>
<li>Secondary Master device role is not currently supported.</li>
</ul>
<h1><a class="anchor" id="r-i3c_b-examples"></a>
Examples</h1>
<h2>I3C Master Basic Example</h2>
<p>This is a basic example of minimal use of the I3C Master in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> i3c_b_master_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> status = <a class="code" href="group___i3_c___b.html#gaa9ce3fda0950ce2aaa0cd8cf51fb5f95">R_I3C_B_Open</a>(&amp;g_i3c_ctrl, &amp;g_i3c_cfg);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <a class="code" href="group___i3_c___a_p_i.html#structi3c__device__cfg__t">i3c_device_cfg_t</a> master_device_cfg =</div><div class="line">    {</div><div class="line">        <span class="comment">/* This is the Static I3C / I2C Legacy address defined by the device manufacturer. */</span></div><div class="line">        .<a class="code" href="group___i3_c___a_p_i.html#a77ccba404f1ec93b31a33e6c7ebed26f">static_address</a>  = EXAMPLE_MASTER_STATIC_ADDRESS,</div><div class="line"></div><div class="line">        <span class="comment">/* If the device is a main master, it must configure its own dynamic address. */</span></div><div class="line">        .dynamic_address = EXAMPLE_MASTER_DYNAMIC_ADDRESS,</div><div class="line">    };</div><div class="line"></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga07b0af405a9ca84c45aab74bd1c696c2">R_I3C_B_DeviceCfgSet</a>(&amp;g_i3c_ctrl, &amp;master_device_cfg);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <a class="code" href="group___i3_c___a_p_i.html#structi3c__device__table__cfg__t">i3c_device_table_cfg_t</a> device_table_cfg =</div><div class="line">    {</div><div class="line">        <span class="comment">/* This is the Static I3C / I2C Legacy address defined by the device manufacturer. */</span></div><div class="line">        .<a class="code" href="group___i3_c___a_p_i.html#a028f83c75b6bdc0155b5ee9abc822225">static_address</a>        = EXAMPLE_STATIC_ADDRESS,</div><div class="line"></div><div class="line">        <span class="comment">/* Dynamic address is not used in I2C. */</span></div><div class="line">        .dynamic_address       = EXAMPLE_DYNAMIC_ADDRESS,</div><div class="line"></div><div class="line">        <span class="comment">/* This is the type of device. It may be either an I2C device or an I3C device. */</span></div><div class="line">        .device_protocol       = <a class="code" href="group___i3_c___a_p_i.html#ggaa7585dee427a1d95926f88dd55ecf305a6b32868175ba9fb454f459441be611be">I3C_DEVICE_PROTOCOL_I3C</a>,</div><div class="line"></div><div class="line">        .ibi_accept            = <span class="keyword">false</span>, </div><div class="line"></div><div class="line">        <span class="comment">/* Depending on the device the IBI requests may have a data payload.</span></div><div class="line"><span class="comment">         * Note that this field will be automatically updated if the device is configured using ENTDAA.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        .ibi_payload           = <span class="keyword">false</span>,</div><div class="line"></div><div class="line">        <span class="comment">/* Master requests cannot be accepted because Secondary Master is not supported. */</span></div><div class="line">        .master_request_accept = <span class="keyword">false</span>,</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Set the device configuration in the master device table. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga9517cc752212a1423f0153c4330943b4">R_I3C_B_MasterDeviceTableSet</a>(&amp;g_i3c_ctrl, 0, &amp;device_table_cfg);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the I3C device. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#gae1dcb91a0152da9a6676ee27d305dceb">R_I3C_B_Enable</a>(&amp;g_i3c_ctrl);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Start assigning dynamic addresses to devices on the bus using the ENTDAA command. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga014e6425d49e19f05d24fd345a785589">R_I3C_B_DynamicAddressAssignmentStart</a>(&amp;g_i3c_ctrl, <a class="code" href="group___i3_c___a_p_i.html#gga6ebef50cdf52650f03e1b449325779fca747529dae6e854111df4e95e9ba3c91a">I3C_ADDRESS_ASSIGNMENT_MODE_ENTDAA</a>, 0, 1);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for dynamic address assignment to complete. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca178a51755c49a2a63cf7b376b2578f2a">I3C_EVENT_ADDRESS_ASSIGNMENT_COMPLETE</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Select the configured device and bitrate mode for the following operations. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga2a3f7414a893b9c2b9135523c8f6d950">R_I3C_B_DeviceSelect</a>(&amp;g_i3c_ctrl, 0, <a class="code" href="group___i3_c___b.html#ggac8fb0ec859c44282b8323eb13de6ad3ca30e9d9ea007ba5c667387f1198721ff9">I3C_B_BITRATE_MODE_I3C_SDR0_STDBR</a>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Start a write transfer. */</span></div><div class="line">    <span class="keyword">static</span> uint8_t p_write_buffer[] = {1, 2, 3, 4, 5};</div><div class="line">    status = <a class="code" href="group___i3_c___b.html#gadf661fd87ee8c33efd8801d59997d4a1">R_I3C_B_Write</a>(&amp;g_i3c_ctrl, p_write_buffer, <span class="keyword">sizeof</span>(p_write_buffer), <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the write transfer to complete. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Start a read transfer. */</span></div><div class="line">    <span class="keyword">static</span> uint8_t p_read_buffer[16];</div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga69047e20f165f6e44fea97f3fec69399">R_I3C_B_Read</a>(&amp;g_i3c_ctrl, p_read_buffer, <span class="keyword">sizeof</span>(p_read_buffer), <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the read transfer to complete. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* This function is called by the I3C driver from ISRs in order to notify the application of I3C events. */</span></div><div class="line"><span class="keywordtype">void</span> i3c_b_master_basic_example_callback (<a class="code" href="group___i3_c___a_p_i.html#structi3c__callback__args__t">i3c_callback_args_t</a> <span class="keyword">const</span> * <span class="keyword">const</span> p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___i3_c___a_p_i.html#a558180776a16d59f446a936574353300">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cadfebca77a845caf0935ca9647c66eb67">I3C_EVENT_ENTDAA_ADDRESS_PHASE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* The device PID, DCR, and BCR registers will be available in i3c_callback_args_t::p_slave_info. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca178a51755c49a2a63cf7b376b2578f2a">I3C_EVENT_ADDRESS_ASSIGNMENT_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca178a51755c49a2a63cf7b376b2578f2a">I3C_EVENT_ADDRESS_ASSIGNMENT_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* The number of bytes read from the slave will be available in i3c_callback_args_t::transfer_size. */</span></div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2>I3C Slave Basic Example</h2>
<p>This is a basic example of minimal use of the I3C Slave in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_slave_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> status = <a class="code" href="group___i3_c___b.html#gaa9ce3fda0950ce2aaa0cd8cf51fb5f95">R_I3C_B_Open</a>(&amp;g_i3c_ctrl, &amp;g_i3c_cfg);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <a class="code" href="group___i3_c___a_p_i.html#structi3c__device__cfg__t">i3c_device_cfg_t</a> slave_device_cfg =</div><div class="line">    {</div><div class="line">        <span class="comment">/* This is the Static I3C / I2C Legacy address defined by the device manufacturer. */</span></div><div class="line">        .<a class="code" href="group___i3_c___a_p_i.html#a77ccba404f1ec93b31a33e6c7ebed26f">static_address</a>  = EXAMPLE_STATIC_ADDRESS,</div><div class="line"></div><div class="line">        <span class="comment">/* The dynamic address will be automatically updated when the master configures this device using ENTDAA. */</span></div><div class="line">        .dynamic_address = 0,</div><div class="line"></div><div class="line">        <span class="comment">/* Device Registers that are read by the master. */</span></div><div class="line">        .slave_info      =</div><div class="line">        {</div><div class="line">            .bcr = EXAMPLE_BCR_SETTING,</div><div class="line">            .dcr = EXAMPLE_DCR_SETTING,</div><div class="line">            .pid =</div><div class="line">            {</div><div class="line">                0, 1, 2, 3, 4, 5</div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Set the device configuration for this device. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga07b0af405a9ca84c45aab74bd1c696c2">R_I3C_B_DeviceCfgSet</a>(&amp;g_i3c_ctrl, &amp;slave_device_cfg);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable Slave Mode. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#gae1dcb91a0152da9a6676ee27d305dceb">R_I3C_B_Enable</a>(&amp;g_i3c_ctrl);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> uint8_t p_read_buffer[EXAMPLE_READ_BUFFER_SIZE];</div><div class="line">    <span class="keyword">static</span> uint8_t p_write_buffer[EXAMPLE_WRITE_BUFFER_SIZE];</div><div class="line"></div><div class="line">    <span class="comment">/* Set the buffer for storing data received during a read transfer. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga69047e20f165f6e44fea97f3fec69399">R_I3C_B_Read</a>(&amp;g_i3c_ctrl, p_read_buffer, <span class="keyword">sizeof</span>(p_read_buffer), <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the master to complete a read transfer. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the write buffer that will be transmitted during a write transfer. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#gadf661fd87ee8c33efd8801d59997d4a1">R_I3C_B_Write</a>(&amp;g_i3c_ctrl, p_write_buffer, <span class="keyword">sizeof</span>(p_write_buffer), <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the master to complete a write transfer. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_slave_basic_example_callback (<a class="code" href="group___i3_c___a_p_i.html#structi3c__callback__args__t">i3c_callback_args_t</a> <span class="keyword">const</span> * <span class="keyword">const</span> p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___i3_c___a_p_i.html#a558180776a16d59f446a936574353300">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca178a51755c49a2a63cf7b376b2578f2a">I3C_EVENT_ADDRESS_ASSIGNMENT_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca178a51755c49a2a63cf7b376b2578f2a">I3C_EVENT_ADDRESS_ASSIGNMENT_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca401943802babdddf23fdc32573c220d2">I3C_EVENT_READ_BUFFER_FULL</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* If there is no user provided read buffer, or if the user provided read buffer has been filled,</span></div><div class="line"><span class="comment">             * the driver will notify the application that the buffer is full. The application may provide</span></div><div class="line"><span class="comment">             * a new read buffer by calling i3c_b_api_t::read. If no read buffer is provided, then any remaining bytes</span></div><div class="line"><span class="comment">             * in the transfer will be dropped. */</span></div><div class="line">            uint8_t * p_read_buffer = i3c_b_app_next_read_buffer_get();</div><div class="line">            <a class="code" href="group___i3_c___b.html#ga69047e20f165f6e44fea97f3fec69399">R_I3C_B_Read</a>(&amp;g_i3c_ctrl, p_read_buffer, EXAMPLE_READ_BUFFER_SIZE, <span class="keyword">false</span>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* The number of bytes read by the slave will be available in i3c_callback_args_t::transfer_size. */</span></div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>);</div><div class="line"></div><div class="line">            <span class="comment">/* Note that the application may also call i3c_b_api_t::read or i3c_b_api_t::write from this event</span></div><div class="line"><span class="comment">             * In order to set the transfer buffers for the next transfer. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* The number of bytes written by the slave will be available in i3c_callback_args_t::transfer_size. */</span></div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>);</div><div class="line"></div><div class="line">            <span class="comment">/* Note that the application may also call i3c_b_api_t::read or i3c_b_api_t::write from this event</span></div><div class="line"><span class="comment">             * In order to set the transfer buffers for the next transfer. */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>I2C Legacy Basic Example</h2>
<p>This is a basic example of minimal use of I2C Legacy transfers in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> i2c_legacy_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> status = <a class="code" href="group___i3_c___b.html#gaa9ce3fda0950ce2aaa0cd8cf51fb5f95">R_I3C_B_Open</a>(&amp;g_i3c_ctrl, &amp;g_i3c_cfg);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <a class="code" href="group___i3_c___a_p_i.html#structi3c__device__cfg__t">i3c_device_cfg_t</a> master_device_cfg =</div><div class="line">    {</div><div class="line">        <span class="comment">/* This is the Static I3C / I2C Legacy address defined by the device manufacturer. */</span></div><div class="line">        .<a class="code" href="group___i3_c___a_p_i.html#a77ccba404f1ec93b31a33e6c7ebed26f">static_address</a>  = EXAMPLE_MASTER_STATIC_ADDRESS,</div><div class="line"></div><div class="line">        <span class="comment">/* If the device is a main master, it must configure its own dynamic address. */</span></div><div class="line">        .dynamic_address = EXAMPLE_MASTER_DYNAMIC_ADDRESS,</div><div class="line">    };</div><div class="line"></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga07b0af405a9ca84c45aab74bd1c696c2">R_I3C_B_DeviceCfgSet</a>(&amp;g_i3c_ctrl, &amp;master_device_cfg);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <a class="code" href="group___i3_c___a_p_i.html#structi3c__device__table__cfg__t">i3c_device_table_cfg_t</a> device_table_cfg =</div><div class="line">    {</div><div class="line">        <span class="comment">/* This is the Static I3C / I2C Legacy address defined by the device manufacturer. */</span></div><div class="line">        .<a class="code" href="group___i3_c___a_p_i.html#a028f83c75b6bdc0155b5ee9abc822225">static_address</a>        = EXAMPLE_STATIC_ADDRESS,</div><div class="line"></div><div class="line">        <span class="comment">/* Dynamic address is not used in I2C. */</span></div><div class="line">        .dynamic_address       = 0,</div><div class="line"></div><div class="line">        <span class="comment">/* This is the type of device. It may be either an I2C device or an I3C device. */</span></div><div class="line">        .device_protocol       = <a class="code" href="group___i3_c___a_p_i.html#ggaa7585dee427a1d95926f88dd55ecf305a68c12b56610277eac342a9aa5b5fcb1b">I3C_DEVICE_PROTOCOL_I2C</a>,</div><div class="line"></div><div class="line">        <span class="comment">/* These options are not used in I2C. */</span></div><div class="line">        .ibi_accept            = <span class="keyword">false</span>, </div><div class="line"></div><div class="line">        <span class="comment">/* Depending on the device the IBI requests may have a data payload.</span></div><div class="line"><span class="comment">         * Note that this field will be automatically updated if the device is configured using ENTDAA.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        .ibi_payload           = <span class="keyword">false</span>,</div><div class="line"></div><div class="line">        <span class="comment">/* Master requests cannot be accepted because Secondary Master is not supported. */</span></div><div class="line">        .master_request_accept = <span class="keyword">false</span>,</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Set the device configuration in the master device table. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga9517cc752212a1423f0153c4330943b4">R_I3C_B_MasterDeviceTableSet</a>(&amp;g_i3c_ctrl, 0, &amp;device_table_cfg);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the I3C device. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#gae1dcb91a0152da9a6676ee27d305dceb">R_I3C_B_Enable</a>(&amp;g_i3c_ctrl);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Select the configured device for the following operations. */</span></div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga2a3f7414a893b9c2b9135523c8f6d950">R_I3C_B_DeviceSelect</a>(&amp;g_i3c_ctrl, 0, <a class="code" href="group___i3_c___b.html#ggac8fb0ec859c44282b8323eb13de6ad3caf4dc5a9d144776169e8a4d7f21a93b84">I3C_B_BITRATE_MODE_I2C_STDBR</a>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Start a write transfer. */</span></div><div class="line">    <span class="keyword">static</span> uint8_t p_write_data[] = {1, 2, 3, 4, 5};</div><div class="line">    status = <a class="code" href="group___i3_c___b.html#gadf661fd87ee8c33efd8801d59997d4a1">R_I3C_B_Write</a>(&amp;g_i3c_ctrl, p_write_data, <span class="keyword">sizeof</span>(p_write_data), <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the write transfer to complete. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Start a read transfer. */</span></div><div class="line">    <span class="keyword">static</span> uint8_t p_read_data[16];</div><div class="line">    status = <a class="code" href="group___i3_c___b.html#ga69047e20f165f6e44fea97f3fec69399">R_I3C_B_Read</a>(&amp;g_i3c_ctrl, p_read_data, <span class="keyword">sizeof</span>(p_read_data), <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the read transfer to complete. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> i2c_legacy_basic_example_callback (<a class="code" href="group___i3_c___a_p_i.html#structi3c__callback__args__t">i3c_callback_args_t</a> <span class="keyword">const</span> * <span class="keyword">const</span> p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___i3_c___a_p_i.html#a558180776a16d59f446a936574353300">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9379590b2f8f1411715ba425c6c15a4b">I3C_EVENT_WRITE_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* The number of bytes read from the slave will be available in i3c_callback_args_t::transfer_size. */</span></div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cabfc8612eeb0cd4e93456d6844686c135">I3C_EVENT_READ_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>I3C Master In-band Interrupts Example</h2>
<p>This is a basic example of reading In-band Interrupts in I3C Master mode.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_master_ibi_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t p_ibi_read_buffer[EXAMPLE_READ_BUFFER_SIZE] = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Set the buffer for storing IBI data that is read from the slave. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> status = <a class="code" href="group___i3_c___b.html#gad786c546168aabcc04099f73a540af29">R_I3C_B_IbiRead</a>(&amp;g_i3c_ctrl, p_ibi_read_buffer, <span class="keyword">sizeof</span>(p_ibi_read_buffer));</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the ibiRead transfer to complete.</span></div><div class="line"><span class="comment">     * Note that the master does not need to wait for the IBI, and can start other operations. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9af3b8a5b489c8cd30b2f563b4323f5e">I3C_EVENT_IBI_READ_COMPLETE</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_master_ibi_basic_example_callback (<a class="code" href="group___i3_c___a_p_i.html#structi3c__callback__args__t">i3c_callback_args_t</a> <span class="keyword">const</span> * <span class="keyword">const</span> p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___i3_c___a_p_i.html#a558180776a16d59f446a936574353300">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265cac5b7d7a4cdbe9197e4c6034008270fa8">I3C_EVENT_IBI_READ_BUFFER_FULL</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* If there is no user provided ibiRead buffer, or if the user provided ibiRead buffer has been filled,</span></div><div class="line"><span class="comment">             * the driver will notify the application that the buffer is full. The application may provide</span></div><div class="line"><span class="comment">             * a new read buffer by calling i3c_b_api_t::ibiRead. If no read buffer is provided, then any remaining bytes</span></div><div class="line"><span class="comment">             * in the transfer will be dropped. */</span></div><div class="line">            uint8_t * p_read_buffer = i3c_b_app_next_read_buffer_get();</div><div class="line">            <a class="code" href="group___i3_c___b.html#gad786c546168aabcc04099f73a540af29">R_I3C_B_IbiRead</a>(&amp;g_i3c_ctrl, p_read_buffer, EXAMPLE_READ_BUFFER_SIZE);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9af3b8a5b489c8cd30b2f563b4323f5e">I3C_EVENT_IBI_READ_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* When an IBI is completed, the transfer_size, ibi_type, and ibi_address will be available in p_args. */</span></div><div class="line">            <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___i3_c___a_p_i.html#a38189a6ab614f521924609c5bb5f30b9">ibi_type</a>)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#gga81ac58196d67e74a0a3702c3e760ede7a29e66a0c093804099f1680935b8390a7">I3C_IBI_TYPE_INTERRUPT</a>:</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Notify the application that an IBI was read. */</span></div><div class="line">                    i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca9af3b8a5b489c8cd30b2f563b4323f5e">I3C_EVENT_IBI_READ_COMPLETE</a>);</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#gga81ac58196d67e74a0a3702c3e760ede7ae53f3f0966395df095e951839052c6ca">I3C_IBI_TYPE_HOT_JOIN</a>:</div><div class="line">                {</div><div class="line">                    <span class="comment">/* If a Hot-Join event is received, then the master can initiate the dynamic address assignment procedure. */</span></div><div class="line">                    <a class="code" href="group___i3_c___b.html#ga014e6425d49e19f05d24fd345a785589">R_I3C_B_DynamicAddressAssignmentStart</a>(&amp;g_i3c_ctrl, <a class="code" href="group___i3_c___a_p_i.html#gga6ebef50cdf52650f03e1b449325779fca747529dae6e854111df4e95e9ba3c91a">I3C_ADDRESS_ASSIGNMENT_MODE_ENTDAA</a>, 0, 1);</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">default</span>:</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>I3C Slave In-band Interrupts Example</h2>
<p>This is a basic example of writing In-band Interrupts in I3C Slave mode.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_slave_ibi_write_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t ibi_write_buffer[EXAMPLE_WRITE_BUFFER_SIZE] = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Initiate an In-band interrupt in slave mode.</span></div><div class="line"><span class="comment">     * Note: If the slave does not have an IBI payload or if it is a Hot-Join request, the write buffer should be set</span></div><div class="line"><span class="comment">     *       to NULL and the write length should be set to 0. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> status =</div><div class="line">        <a class="code" href="group___i3_c___b.html#ga0b4af888ebc4c210feea2a149fd4cfc1">R_I3C_B_IbiWrite</a>(&amp;g_i3c_ctrl, <a class="code" href="group___i3_c___a_p_i.html#gga81ac58196d67e74a0a3702c3e760ede7a29e66a0c093804099f1680935b8390a7">I3C_IBI_TYPE_INTERRUPT</a>, ibi_write_buffer, <span class="keyword">sizeof</span>(ibi_write_buffer));</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the ibiWrite transfer to complete. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca49e2d860a954f25bfee5d3f6755d3b54">I3C_EVENT_IBI_WRITE_COMPLETE</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_slave_ibi_write_basic_example_callback (<a class="code" href="group___i3_c___a_p_i.html#structi3c__callback__args__t">i3c_callback_args_t</a> <span class="keyword">const</span> * <span class="keyword">const</span> p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___i3_c___a_p_i.html#a558180776a16d59f446a936574353300">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca49e2d860a954f25bfee5d3f6755d3b54">I3C_EVENT_IBI_WRITE_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Notify the application that the IBI write is complete. */</span></div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca49e2d860a954f25bfee5d3f6755d3b54">I3C_EVENT_IBI_WRITE_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>I3C Master Common Command Codes Example</h2>
<p>This is a basic example of sending Common Command Codes in I3C Master mode.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_master_ccc_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> uint8_t command_buffer[EXAMPLE_READ_BUFFER_SIZE] = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Setup the command descriptor. */</span></div><div class="line">    <span class="keyword">static</span> <a class="code" href="group___i3_c___a_p_i.html#structi3c__command__descriptor__t">i3c_command_descriptor_t</a> command_descriptor =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___i3_c___a_p_i.html#a1319595692f1d7d2035df8f8fd63445a">command_code</a> = <a class="code" href="group___i3_c___a_p_i.html#ggae0fcac252ef200a5a24cdadfa123dc52af39fa810aa779ab934064116903c409f">I3C_CCC_DIRECT_GETSTATUS</a>,</div><div class="line"></div><div class="line">        <span class="comment">/* Set a buffer for storing the data read by the command. */</span></div><div class="line">        .p_buffer     = command_buffer,</div><div class="line"></div><div class="line">        <span class="comment">/* The length for a GETSTATUS command is 2 bytes. */</span></div><div class="line">        .length       = 2,</div><div class="line"></div><div class="line">        <span class="comment">/* Terminate the transfer with a STOP condition. */</span></div><div class="line">        .restart      = <span class="keyword">false</span>,</div><div class="line"></div><div class="line">        <span class="comment">/* The GETSTATUS command is a Direct Get Command so rnw should be true. */</span></div><div class="line">        .rnw          = <span class="keyword">true</span>,</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Send the command. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> status = <a class="code" href="group___i3_c___b.html#ga36ef6e15732ea09c5ad2fb19095cae4e">R_I3C_B_CommandSend</a>(&amp;g_i3c_ctrl, &amp;command_descriptor);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the command to complete. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca2e5a0467001efaba19b6c2de17d182be">I3C_EVENT_COMMAND_COMPLETE</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* The command_buffer will have the status info that was read from the slave device. */</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_master_ccc_example_callback (<a class="code" href="group___i3_c___a_p_i.html#structi3c__callback__args__t">i3c_callback_args_t</a> <span class="keyword">const</span> * <span class="keyword">const</span> p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___i3_c___a_p_i.html#a558180776a16d59f446a936574353300">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca2e5a0467001efaba19b6c2de17d182be">I3C_EVENT_COMMAND_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* Notify the application that the command is complete. */</span></div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca2e5a0467001efaba19b6c2de17d182be">I3C_EVENT_COMMAND_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>I3C Slave Common Command Codes Example</h2>
<p>This is a basic example of receiving Common Command Codes in I3C Slave mode.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_slave_ccc_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t read_buffer[EXAMPLE_READ_BUFFER_SIZE] = {0};</div><div class="line"></div><div class="line">    <span class="comment">/* Broadcast and Direct Set commands will be read into the read_buffer the same way that</span></div><div class="line"><span class="comment">     * a normal SDR Master Write / Slave Read transfer is read. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> status = <a class="code" href="group___i3_c___b.html#ga69047e20f165f6e44fea97f3fec69399">R_I3C_B_Read</a>(&amp;g_i3c_ctrl, read_buffer, <span class="keyword">sizeof</span>(read_buffer), <span class="keyword">false</span>);</div><div class="line">    assert(FSP_SUCCESS == status);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for the command to complete. */</span></div><div class="line">    i3c_b_app_event_wait(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca2e5a0467001efaba19b6c2de17d182be">I3C_EVENT_COMMAND_COMPLETE</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> i3c_b_slave_ccc_example_callback (<a class="code" href="group___i3_c___a_p_i.html#structi3c__callback__args__t">i3c_callback_args_t</a> <span class="keyword">const</span> * <span class="keyword">const</span> p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">switch</span> (p_args-&gt;<a class="code" href="group___i3_c___a_p_i.html#a558180776a16d59f446a936574353300">event</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca2e5a0467001efaba19b6c2de17d182be">I3C_EVENT_COMMAND_COMPLETE</a>:</div><div class="line">        {</div><div class="line">            <span class="comment">/* The command code and transfer size will be available in p_args.</span></div><div class="line"><span class="comment">             * If the command code is a Broadcast or Direct Set, then data will</span></div><div class="line"><span class="comment">             * be stored in the read buffer provided by i3c_b_api_t::read.</span></div><div class="line"><span class="comment">             * If the command code is a Direct Get, then the data will be automatically</span></div><div class="line"><span class="comment">             * sent from device SFR. */</span></div><div class="line">            i3c_b_app_event_notify(<a class="code" href="group___i3_c___a_p_i.html#ggaaeacda02a21254776fcbc47ab1ff265ca2e5a0467001efaba19b6c2de17d182be">I3C_EVENT_COMMAND_COMPLETE</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structi3c__b__clock__stalling__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#structi3c__b__clock__stalling__t">i3c_b_clock_stalling_t</a></td></tr>
<tr class="separator:structi3c__b__clock__stalling__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structi3c__b__bitrate__settings__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#structi3c__b__bitrate__settings__t">i3c_b_bitrate_settings_t</a></td></tr>
<tr class="separator:structi3c__b__bitrate__settings__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structi3c__b__ibi__control__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#structi3c__b__ibi__control__t">i3c_b_ibi_control_t</a></td></tr>
<tr class="separator:structi3c__b__ibi__control__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structi3c__b__slave__command__response__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#structi3c__b__slave__command__response__info__t">i3c_b_slave_command_response_info_t</a></td></tr>
<tr class="separator:structi3c__b__slave__command__response__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structi3c__b__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#structi3c__b__instance__ctrl__t">i3c_b_instance_ctrl_t</a></td></tr>
<tr class="separator:structi3c__b__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structi3c__b__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#structi3c__b__extended__cfg__t">i3c_b_extended_cfg_t</a></td></tr>
<tr class="separator:structi3c__b__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga613539c3294eadbba8386934530c042d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga613539c3294eadbba8386934530c042d">I3C_B_ERROR_RECOVERY_VERSION_1</a></td></tr>
<tr class="memdesc:ga613539c3294eadbba8386934530c042d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support error recovery procedure for chip version 1.  <a href="#ga613539c3294eadbba8386934530c042d">More...</a><br /></td></tr>
<tr class="separator:ga613539c3294eadbba8386934530c042d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a9316af0c201865007526dbd8ef35c"><td class="memItemLeft" align="right" valign="top"><a id="ga37a9316af0c201865007526dbd8ef35c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga37a9316af0c201865007526dbd8ef35c">I3C_B_ERROR_RECOVERY_VERSION_2</a></td></tr>
<tr class="memdesc:ga37a9316af0c201865007526dbd8ef35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support error recovery procedure for chip version 2. <br /></td></tr>
<tr class="separator:ga37a9316af0c201865007526dbd8ef35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3877dd4ca46a098b55ac20fe3303a87d"><td class="memItemLeft" align="right" valign="top"><a id="ga3877dd4ca46a098b55ac20fe3303a87d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga3877dd4ca46a098b55ac20fe3303a87d">I3C_B_ERROR_RECOVERY_VERSION_BOTH</a></td></tr>
<tr class="memdesc:ga3877dd4ca46a098b55ac20fe3303a87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support error recovery procedure for chip version 1 and version 2. <br /></td></tr>
<tr class="separator:ga3877dd4ca46a098b55ac20fe3303a87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394142d1aa7177899d19d06d6fae6f89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga394142d1aa7177899d19d06d6fae6f89">I3C_B_DEVICE_INDEX_EXTENDED_DEVICE</a></td></tr>
<tr class="separator:ga394142d1aa7177899d19d06d6fae6f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e705cb2af31c57eacd0492b2417145"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga66e705cb2af31c57eacd0492b2417145">I3C_B_EVENT_STATUS_SUCCESS</a></td></tr>
<tr class="memdesc:ga66e705cb2af31c57eacd0492b2417145"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transfer was completed as expected.  <a href="#ga66e705cb2af31c57eacd0492b2417145">More...</a><br /></td></tr>
<tr class="separator:ga66e705cb2af31c57eacd0492b2417145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20332b13e43cafe1a0ee0dbc195d7467"><td class="memItemLeft" align="right" valign="top"><a id="ga20332b13e43cafe1a0ee0dbc195d7467"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga20332b13e43cafe1a0ee0dbc195d7467">I3C_B_EVENT_STATUS_PARITY</a></td></tr>
<tr class="memdesc:ga20332b13e43cafe1a0ee0dbc195d7467"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parity error was detected. <br /></td></tr>
<tr class="separator:ga20332b13e43cafe1a0ee0dbc195d7467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c155a91650485e935a7d95b65bf6ea1"><td class="memItemLeft" align="right" valign="top"><a id="ga4c155a91650485e935a7d95b65bf6ea1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga4c155a91650485e935a7d95b65bf6ea1">I3C_B_EVENT_STATUS_FRAME</a></td></tr>
<tr class="memdesc:ga4c155a91650485e935a7d95b65bf6ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A frame error was detected. <br /></td></tr>
<tr class="separator:ga4c155a91650485e935a7d95b65bf6ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bffde187fcf342dfc6cabc1a7353d8"><td class="memItemLeft" align="right" valign="top"><a id="gab4bffde187fcf342dfc6cabc1a7353d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gab4bffde187fcf342dfc6cabc1a7353d8">I3C_B_EVENT_STATUS_ADDRESS_HEADER</a></td></tr>
<tr class="memdesc:gab4bffde187fcf342dfc6cabc1a7353d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Address Header error wasdetected. <br /></td></tr>
<tr class="separator:gab4bffde187fcf342dfc6cabc1a7353d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac076b32d443c844645e0d1e9a6d184e"><td class="memItemLeft" align="right" valign="top"><a id="gaac076b32d443c844645e0d1e9a6d184e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gaac076b32d443c844645e0d1e9a6d184e">I3C_B_EVENT_STATUS_NACK</a></td></tr>
<tr class="memdesc:gaac076b32d443c844645e0d1e9a6d184e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transfer was NACK'd. <br /></td></tr>
<tr class="separator:gaac076b32d443c844645e0d1e9a6d184e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103bea85dbeeb58f40d85e3b1bd00fae"><td class="memItemLeft" align="right" valign="top"><a id="ga103bea85dbeeb58f40d85e3b1bd00fae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga103bea85dbeeb58f40d85e3b1bd00fae">I3C_B_EVENT_STATUS_OVERFLOW</a></td></tr>
<tr class="memdesc:ga103bea85dbeeb58f40d85e3b1bd00fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Receive FIFO overflow or Transmit FIFO underflow occurred. <br /></td></tr>
<tr class="separator:ga103bea85dbeeb58f40d85e3b1bd00fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae15f0c28a3098b35b3eaf0456f1c4a5b"><td class="memItemLeft" align="right" valign="top"><a id="gae15f0c28a3098b35b3eaf0456f1c4a5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gae15f0c28a3098b35b3eaf0456f1c4a5b">I3C_B_EVENT_STATUS_ABORTED_TO_MASTER</a></td></tr>
<tr class="memdesc:gae15f0c28a3098b35b3eaf0456f1c4a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">In slave mode, the write transfer was ended via the 'T' bit. <br /></td></tr>
<tr class="separator:gae15f0c28a3098b35b3eaf0456f1c4a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aed8b3fb4cfd7004b8f785a8884f4ff"><td class="memItemLeft" align="right" valign="top"><a id="ga7aed8b3fb4cfd7004b8f785a8884f4ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga7aed8b3fb4cfd7004b8f785a8884f4ff">I3C_B_EVENT_STATUS_ABORTED</a></td></tr>
<tr class="memdesc:ga7aed8b3fb4cfd7004b8f785a8884f4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">In master mode, the transfer was aborted. <br /></td></tr>
<tr class="separator:ga7aed8b3fb4cfd7004b8f785a8884f4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf3c8a9a14870a0e66c8815bed1c2e5"><td class="memItemLeft" align="right" valign="top"><a id="gaacf3c8a9a14870a0e66c8815bed1c2e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gaacf3c8a9a14870a0e66c8815bed1c2e5">I3C_B_EVENT_STATUS_IBI_NACK_DISABLED</a></td></tr>
<tr class="memdesc:gaacf3c8a9a14870a0e66c8815bed1c2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IBI was NACK'd and the a DISEC command was sent. <br /></td></tr>
<tr class="separator:gaacf3c8a9a14870a0e66c8815bed1c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac8fb0ec859c44282b8323eb13de6ad3c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gac8fb0ec859c44282b8323eb13de6ad3c">i3c_b_bitrate_mode_t</a> </td></tr>
<tr class="separator:gac8fb0ec859c44282b8323eb13de6ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ffca78d7da057f277bfd8ce2ef2e1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gab3ffca78d7da057f277bfd8ce2ef2e1a">i3c_b_activity_state_t</a> </td></tr>
<tr class="separator:gab3ffca78d7da057f277bfd8ce2ef2e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa100c24dc68792009da85deed2f6387a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#gaa100c24dc68792009da85deed2f6387a">i3c_b_data_rate_setting_t</a> </td></tr>
<tr class="separator:gaa100c24dc68792009da85deed2f6387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3289540419912324ce02f19ed6a972ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ga3289540419912324ce02f19ed6a972ca">i3c_b_clock_data_turnaround_t</a> </td></tr>
<tr class="separator:ga3289540419912324ce02f19ed6a972ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structi3c__b__clock__stalling__t" id="structi3c__b__clock__stalling__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structi3c__b__clock__stalling__t">&#9670;&nbsp;</a></span>i3c_b_clock_stalling_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct i3c_b_clock_stalling_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Clock stalling settings. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a130da5bdcc977cc2ac80d2958ee0ed2c"></a>uint32_t</td>
<td class="fieldname">
assigned_address_phase_enable: 1</td>
<td class="fielddoc">
Enable Clock Stalling during the address phase of the ENTDAA command. </td></tr>
<tr><td class="fieldtype">
<a id="aa24d69aa4e272b08ea25115bdd653871"></a>uint32_t</td>
<td class="fieldname">
transition_phase_enable: 1</td>
<td class="fielddoc">
Enable Clock Stalling during the transition bit in read transfers. </td></tr>
<tr><td class="fieldtype">
<a id="abf6047ed6b80423a3e34c58d7e6f2159"></a>uint32_t</td>
<td class="fieldname">
parity_phase_enable: 1</td>
<td class="fielddoc">
Enable Clock Stalling during the parity bit period in write transfers. </td></tr>
<tr><td class="fieldtype">
<a id="a111fd70be18b905f2dcd177090e28e95"></a>uint32_t</td>
<td class="fieldname">
ack_phase_enable: 1</td>
<td class="fielddoc">
Enable Clock Stalling during the ACK/NACK phase. </td></tr>
<tr><td class="fieldtype">
<a id="a7a0a2568821deca8dde989c04e3bf3c3"></a>uint16_t</td>
<td class="fieldname">
clock_stalling_time</td>
<td class="fielddoc">
The amount of time to stall the clock in I3C source clock ticks. </td></tr>
</table>

</div>
</div>
<a name="structi3c__b__bitrate__settings__t" id="structi3c__b__bitrate__settings__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structi3c__b__bitrate__settings__t">&#9670;&nbsp;</a></span>i3c_b_bitrate_settings_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct i3c_b_bitrate_settings_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Bitrate settings for configuring the SCL clock frequency. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aee8857dcfc0a90a83e4431ccbd4746e8"></a>uint32_t</td>
<td class="fieldname">
stdbr</td>
<td class="fielddoc">
The standard bitrate settings. </td></tr>
<tr><td class="fieldtype">
<a id="a43f54168433c048558d579ba300f565d"></a>uint32_t</td>
<td class="fieldname">
extbr</td>
<td class="fielddoc">
The extended bitrate settings. </td></tr>
<tr><td class="fieldtype">
<a id="a7e9faafe29396be004f769cd35b81563"></a><a class="el" href="group___i3_c___b.html#structi3c__b__clock__stalling__t">i3c_b_clock_stalling_t</a></td>
<td class="fieldname">
clock_stalling</td>
<td class="fielddoc">
<p>Clock Stalling settings (See Master Clock Stalling in the MIPI I3C Specification v1.0). </p>
</td></tr>
</table>

</div>
</div>
<a name="structi3c__b__ibi__control__t" id="structi3c__b__ibi__control__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structi3c__b__ibi__control__t">&#9670;&nbsp;</a></span>i3c_b_ibi_control_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct i3c_b_ibi_control_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Settings for controlling the drivers behavior in response to IBIs. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a493e09410ad1e54a74ef9ecd93dbfd4e"></a>uint32_t</td>
<td class="fieldname">
hot_join_acknowledge: 1</td>
<td class="fielddoc">
If false, NACK all Hot Join requests. </td></tr>
<tr><td class="fieldtype">
<a id="aa03b9daf273a95370d743a5ef5bab7dd"></a>uint32_t</td>
<td class="fieldname">
notify_rejected_hot_join_requests: 1</td>
<td class="fielddoc">
Notify the application when an IBI Hot-Join request has been NACK'd. </td></tr>
<tr><td class="fieldtype">
<a id="ad46715479c0a13d5bccb8992cb5edfb2"></a>uint32_t</td>
<td class="fieldname">
notify_rejected_mastership_requests: 1</td>
<td class="fielddoc">
Notify the application when an IBI Mastership request has been NACK'd. </td></tr>
<tr><td class="fieldtype">
<a id="a338fe4fd5a8fab2a3213e25a1572b02c"></a>uint32_t</td>
<td class="fieldname">
notify_rejected_interrupt_requests: 1</td>
<td class="fielddoc">
Notify the application when an IBI Interrupt request has been NACK'd. </td></tr>
</table>

</div>
</div>
<a name="structi3c__b__slave__command__response__info__t" id="structi3c__b__slave__command__response__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structi3c__b__slave__command__response__info__t">&#9670;&nbsp;</a></span>i3c_b_slave_command_response_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct i3c_b_slave_command_response_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Default configuration settings for the slave response to Direct Get Common Command Codes. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae5c638d2a302a6a5c39510137583ffd9"></a>bool</td>
<td class="fieldname">
inband_interrupt_enable</td>
<td class="fielddoc">
Enable IBI interrupts. <p>Slave Event Settings (See ENEC and DISEC in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad84be5ef3adcda517e62810c182ac856"></a>bool</td>
<td class="fieldname">
mastership_request_enable</td>
<td class="fielddoc">
Enable Mastership requests. </td></tr>
<tr><td class="fieldtype">
<a id="ae1391ee53f0f040895bc1a2982db5adf"></a>bool</td>
<td class="fieldname">
hotjoin_request_enable</td>
<td class="fielddoc">
Enable Hot-Join requests. </td></tr>
<tr><td class="fieldtype">
<a id="a667ea08c6f9f2e5f4e3b3354d4fae122"></a><a class="el" href="group___i3_c___b.html#gab3ffca78d7da057f277bfd8ce2ef2e1a">i3c_b_activity_state_t</a></td>
<td class="fieldname">
activity_state</td>
<td class="fielddoc">
<p>Starting Activity State (See ENTASn in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a118058cb130acafed14c05752db449be"></a>uint16_t</td>
<td class="fieldname">
write_length</td>
<td class="fielddoc">
<p>Max Write Length (See SETMWL and GETMWL in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac35a8a2ba71c865f91f85ceb8be2fe65"></a>uint16_t</td>
<td class="fieldname">
read_length</td>
<td class="fielddoc">
<p>Max Read Length (See SETMRL and GETMRL in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab16f7dbd1d812f8dcfc33ac37a939ca9"></a>uint8_t</td>
<td class="fieldname">
ibi_payload_length</td>
<td class="fielddoc">
<p>Number of bytes that will be written by an IBI (See SETMRL and GETMRL in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6e5ccf943f0f06851167cfe40fe7b7a1"></a><a class="el" href="group___i3_c___b.html#gaa100c24dc68792009da85deed2f6387a">i3c_b_data_rate_setting_t</a></td>
<td class="fieldname">
write_data_rate</td>
<td class="fielddoc">
Max Write Data Rate. <p>Max Data Rate Settings (See GETMXDS in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9740e5cb2cd5e45294ebe55929c9daa7"></a><a class="el" href="group___i3_c___b.html#gaa100c24dc68792009da85deed2f6387a">i3c_b_data_rate_setting_t</a></td>
<td class="fieldname">
read_data_rate</td>
<td class="fielddoc">
Max Read Data Rate. </td></tr>
<tr><td class="fieldtype">
<a id="ae51118e339ff8e535dee69acbd4c2c04"></a><a class="el" href="group___i3_c___b.html#ga3289540419912324ce02f19ed6a972ca">i3c_b_clock_data_turnaround_t</a></td>
<td class="fieldname">
clock_data_turnaround</td>
<td class="fielddoc">
Max Data Speed Turnaround. </td></tr>
<tr><td class="fieldtype">
<a id="a680354fe57452deb48fd62692bddf62e"></a>bool</td>
<td class="fieldname">
read_turnaround_time_enable</td>
<td class="fielddoc">
Enable transmission of the of the Max Read Max Read Turnaround Time. </td></tr>
<tr><td class="fieldtype">
<a id="ac817332b7a7317c6edc91a84c329c656"></a>uint32_t</td>
<td class="fieldname">
read_turnaround_time</td>
<td class="fielddoc">
Max Read Turnaround Time. </td></tr>
<tr><td class="fieldtype">
<a id="adebd51c965faf0fe497971c15e669a91"></a>uint8_t</td>
<td class="fieldname">
oscillator_frequency</td>
<td class="fielddoc">
<p>This byte represents the Slave’s internal oscillator frequency in increments of 0.5 MHz (500kHz), up to 127.5 MHz. (See GETXTIME in the MIPI I3C Specification v1.1). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0dbd28cc4de1cbcf7dd3427feef969a2"></a>uint8_t</td>
<td class="fieldname">
oscillator_inaccuracy</td>
<td class="fielddoc">
<p>Oscillator inaccuracy in 0.5% increments of 0% up to 25.5% (See GETXTIME in the MIPI I3C Specification v1.1). </p>
</td></tr>
</table>

</div>
</div>
<a name="structi3c__b__instance__ctrl__t" id="structi3c__b__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structi3c__b__instance__ctrl__t">&#9670;&nbsp;</a></span>i3c_b_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct i3c_b_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Channel control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___i3_c___a_p_i.html#a963e13cc6b3cf1903a01ed87901eb6a9">i3c_api_t::open</a> is called. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ac04ccc58562da71c2a9381b35acdf0d3"><td class="memItemLeft" align="right" valign="top"><a id="ac04ccc58562da71c2a9381b35acdf0d3"></a>
<a class="el" href="group___i3_c___a_p_i.html#structi3c__slave__info__t">i3c_slave_info_t</a> current_slave_info&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ac04ccc58562da71c2a9381b35acdf0d3">BSP_ALIGN_VARIABLE</a> (4)</td></tr>
<tr class="memdesc:ac04ccc58562da71c2a9381b35acdf0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last <a class="el" href="group___i3_c___a_p_i.html#structi3c__slave__info__t">i3c_slave_info_t</a> read during ENTDAA. <br /></td></tr>
<tr class="separator:ac04ccc58562da71c2a9381b35acdf0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ae2ad6ece73c0f4b046708ab96f7c1842"><td class="memItemLeft" align="right" valign="top"><a id="ae2ad6ece73c0f4b046708ab96f7c1842"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ae2ad6ece73c0f4b046708ab96f7c1842">open</a></td></tr>
<tr class="memdesc:ae2ad6ece73c0f4b046708ab96f7c1842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the <a class="el" href="group___i3_c___b.html#ae2ad6ece73c0f4b046708ab96f7c1842" title="Indicates whether the open() API has been successfully called. ">open()</a> API has been successfully called. <br /></td></tr>
<tr class="separator:ae2ad6ece73c0f4b046708ab96f7c1842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be04ad63b14c5df7547285f9c92ba66"><td class="memItemLeft" align="right" valign="top"><a id="a1be04ad63b14c5df7547285f9c92ba66"></a>
R_I3C_B0_Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a1be04ad63b14c5df7547285f9c92ba66">p_reg</a></td></tr>
<tr class="memdesc:a1be04ad63b14c5df7547285f9c92ba66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base register for this channel. <br /></td></tr>
<tr class="separator:a1be04ad63b14c5df7547285f9c92ba66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71e6c3913312c01e121be5ce1f89ae7"><td class="memItemLeft" align="right" valign="top"><a id="ac71e6c3913312c01e121be5ce1f89ae7"></a>
volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ac71e6c3913312c01e121be5ce1f89ae7">internal_state</a></td></tr>
<tr class="memdesc:ac71e6c3913312c01e121be5ce1f89ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to track the current state of the driver. <br /></td></tr>
<tr class="separator:ac71e6c3913312c01e121be5ce1f89ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dcc530b11970be9d3f2fae9dd5dcdc"><td class="memItemLeft" align="right" valign="top"><a id="a48dcc530b11970be9d3f2fae9dd5dcdc"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a48dcc530b11970be9d3f2fae9dd5dcdc">current_command_code</a></td></tr>
<tr class="memdesc:a48dcc530b11970be9d3f2fae9dd5dcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current Common Command Code that is being transferred. <br /></td></tr>
<tr class="separator:a48dcc530b11970be9d3f2fae9dd5dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea03dcc03a3fa25df7a630635c9880f"><td class="memItemLeft" align="right" valign="top"><a id="a5ea03dcc03a3fa25df7a630635c9880f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a5ea03dcc03a3fa25df7a630635c9880f">device_index</a></td></tr>
<tr class="memdesc:a5ea03dcc03a3fa25df7a630635c9880f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device index selected using <a class="el" href="group___i3_c___a_p_i.html#a1e24e768130b9ea12f10743ff3143fa7">i3c_api_t::deviceSelect</a>. <br /></td></tr>
<tr class="separator:a5ea03dcc03a3fa25df7a630635c9880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359e6208b0bd04aab75f6b876d8bead3"><td class="memItemLeft" align="right" valign="top"><a id="a359e6208b0bd04aab75f6b876d8bead3"></a>
<a class="el" href="group___i3_c___b.html#gac8fb0ec859c44282b8323eb13de6ad3c">i3c_b_bitrate_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a359e6208b0bd04aab75f6b876d8bead3">device_bitrate_mode</a></td></tr>
<tr class="memdesc:a359e6208b0bd04aab75f6b876d8bead3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime bitrate settings to use for the next transfer. <br /></td></tr>
<tr class="separator:a359e6208b0bd04aab75f6b876d8bead3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624164578fd3053bde3878a449255aed"><td class="memItemLeft" align="right" valign="top"><a id="a624164578fd3053bde3878a449255aed"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a624164578fd3053bde3878a449255aed">next_word</a></td></tr>
<tr class="memdesc:a624164578fd3053bde3878a449255aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next word that will be written to the FIFO. <br /></td></tr>
<tr class="separator:a624164578fd3053bde3878a449255aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8369efb1618f65a238ce07c438e50c01"><td class="memItemLeft" align="right" valign="top"><a id="a8369efb1618f65a238ce07c438e50c01"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a8369efb1618f65a238ce07c438e50c01">ibi_next_word</a></td></tr>
<tr class="memdesc:a8369efb1618f65a238ce07c438e50c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next word that will be written to the IBI FIFO. <br /></td></tr>
<tr class="separator:a8369efb1618f65a238ce07c438e50c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2144b0ec9924455ca87e11f869af3da6"><td class="memItemLeft" align="right" valign="top"><a id="a2144b0ec9924455ca87e11f869af3da6"></a>
i3c_b_write_buffer_descriptor_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a2144b0ec9924455ca87e11f869af3da6">write_buffer_descriptor</a></td></tr>
<tr class="memdesc:a2144b0ec9924455ca87e11f869af3da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer descriptor for keeping track of a write transfer. <br /></td></tr>
<tr class="separator:a2144b0ec9924455ca87e11f869af3da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231f4fdcb227e5433b99eb4681092ea1"><td class="memItemLeft" align="right" valign="top"><a id="a231f4fdcb227e5433b99eb4681092ea1"></a>
i3c_b_read_buffer_descriptor_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a231f4fdcb227e5433b99eb4681092ea1">read_buffer_descriptor</a></td></tr>
<tr class="memdesc:a231f4fdcb227e5433b99eb4681092ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer descriptor for keeping track of a read transfer. <br /></td></tr>
<tr class="separator:a231f4fdcb227e5433b99eb4681092ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade06559c82b773fb3382aa64c0cbff15"><td class="memItemLeft" align="right" valign="top"><a id="ade06559c82b773fb3382aa64c0cbff15"></a>
i3c_b_read_buffer_descriptor_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ade06559c82b773fb3382aa64c0cbff15">ibi_buffer_descriptor</a></td></tr>
<tr class="memdesc:ade06559c82b773fb3382aa64c0cbff15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer descriptor for keeping track of an IBI read/write transfer. <br /></td></tr>
<tr class="separator:ade06559c82b773fb3382aa64c0cbff15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19839c4573b756f918d79ed7b95db193"><td class="memItemLeft" align="right" valign="top"><a id="a19839c4573b756f918d79ed7b95db193"></a>
volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a19839c4573b756f918d79ed7b95db193">read_transfer_count_final</a></td></tr>
<tr class="memdesc:a19839c4573b756f918d79ed7b95db193"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of bytes read during a read transfer. <br /></td></tr>
<tr class="separator:a19839c4573b756f918d79ed7b95db193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f911a2a8d3071973e2a3f8d9c3379e"><td class="memItemLeft" align="right" valign="top"><a id="ad7f911a2a8d3071973e2a3f8d9c3379e"></a>
volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#ad7f911a2a8d3071973e2a3f8d9c3379e">ibi_transfer_count_final</a></td></tr>
<tr class="memdesc:ad7f911a2a8d3071973e2a3f8d9c3379e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of bytes read during an IBI transfer. <br /></td></tr>
<tr class="separator:ad7f911a2a8d3071973e2a3f8d9c3379e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6292eaa63c5ee2ceefc2c8404aa57fc7"><td class="memItemLeft" align="right" valign="top"><a id="a6292eaa63c5ee2ceefc2c8404aa57fc7"></a>
<a class="el" href="group___i3_c___a_p_i.html#structi3c__cfg__t">i3c_cfg_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i3_c___b.html#a6292eaa63c5ee2ceefc2c8404aa57fc7">p_cfg</a></td></tr>
<tr class="memdesc:a6292eaa63c5ee2ceefc2c8404aa57fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the configuration structure provided during open. <br /></td></tr>
<tr class="separator:a6292eaa63c5ee2ceefc2c8404aa57fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structi3c__b__extended__cfg__t" id="structi3c__b__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structi3c__b__extended__cfg__t">&#9670;&nbsp;</a></span>i3c_b_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct i3c_b_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Extended configuration for r_i3c_b. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a814f21227402c572e9e0f31769a2f7b1"></a><a class="el" href="group___i3_c___b.html#structi3c__b__bitrate__settings__t">i3c_b_bitrate_settings_t</a></td>
<td class="fieldname">
bitrate_settings</td>
<td class="fielddoc">
Bitrate settings configuring the frequency and duty cycle for SCL. </td></tr>
<tr><td class="fieldtype">
<a id="a16e3b94303d38db979568546ac53a4b3"></a><a class="el" href="group___i3_c___b.html#structi3c__b__ibi__control__t">i3c_b_ibi_control_t</a></td>
<td class="fieldname">
ibi_control</td>
<td class="fielddoc">
Configure the driver's behavior in response to IBIs. </td></tr>
<tr><td class="fieldtype">
<a id="a8ed749153af0e8311373e3d2d446ee5d"></a>uint32_t</td>
<td class="fieldname">
bus_free_detection_time</td>
<td class="fielddoc">
<p>The time in I3C reference clock ticks needed in order to detect the bus free condition (See "Bus Free Condition" in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af62dc925b22147aff968321a8ba10fef"></a>uint32_t</td>
<td class="fieldname">
bus_available_detection_time</td>
<td class="fielddoc">
<p>The time in I3C reference clock ticks needed in order to detect the bus available condition (See "Bus Available Condition" in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7e9d0d85bd1aefa8de414728f18b32de"></a>uint32_t</td>
<td class="fieldname">
bus_idle_detection_time</td>
<td class="fielddoc">
<p>The time in I3C reference clock ticks needed in order to detect the bus idle condition (See "Bus Idle Condition" in the MIPI I3C Specification v1.0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7609c913ab9040ddb3884007abe4d661"></a>bool</td>
<td class="fieldname">
timeout_detection_enable</td>
<td class="fielddoc">
Notify the application if SCL is stuck high or low. </td></tr>
<tr><td class="fieldtype">
<a id="a0f2fd857b12b9284dddf430463764016"></a><a class="el" href="group___i3_c___b.html#structi3c__b__slave__command__response__info__t">i3c_b_slave_command_response_info_t</a></td>
<td class="fieldname">
slave_command_response_info</td>
<td class="fielddoc">
<p>Initial settings for configuring the slave's responses to received commands. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5566fbe13d210afcf9538b7f0ef30907"></a>IRQn_Type</td>
<td class="fieldname">
resp_irq</td>
<td class="fielddoc">
Response Queue Full IRQ number. </td></tr>
<tr><td class="fieldtype">
<a id="a65d040ea1c91e96fbc4486e39b51c23d"></a>IRQn_Type</td>
<td class="fieldname">
rx_irq</td>
<td class="fielddoc">
Receive FIFO Full IRQ number. </td></tr>
<tr><td class="fieldtype">
<a id="ae1e8bc40fc3143b2dbb0321efbd677ee"></a>IRQn_Type</td>
<td class="fieldname">
tx_irq</td>
<td class="fielddoc">
Transmit FIFO Empty IRQ number. </td></tr>
<tr><td class="fieldtype">
<a id="a7aabb012263bcc0093e5ed6137b8a701"></a>IRQn_Type</td>
<td class="fieldname">
rcv_irq</td>
<td class="fielddoc">
Receive Status Queue Full IRQ number. </td></tr>
<tr><td class="fieldtype">
<a id="add3c6106157a467818eb480ae5057826"></a>IRQn_Type</td>
<td class="fieldname">
ibi_irq</td>
<td class="fielddoc">
IBI IRQ number. </td></tr>
<tr><td class="fieldtype">
<a id="ac2dd0e54f5699a367af7372aa10630e4"></a>IRQn_Type</td>
<td class="fieldname">
st_irq</td>
<td class="fielddoc">
Start condition IRQ Number. </td></tr>
<tr><td class="fieldtype">
<a id="aeb148883da18117b256353b35b17cbe6"></a>IRQn_Type</td>
<td class="fieldname">
sp_irq</td>
<td class="fielddoc">
Stop condition IRQ Number. </td></tr>
<tr><td class="fieldtype">
<a id="a1ea9841cd4b6b18cd9acc7d7f53fa64d"></a>IRQn_Type</td>
<td class="fieldname">
tmo_irq</td>
<td class="fielddoc">
Timeout IRQ Number. </td></tr>
<tr><td class="fieldtype">
<a id="a2182f261e10335bf21ca40bc09bcd68d"></a>IRQn_Type</td>
<td class="fieldname">
ierr_irq</td>
<td class="fielddoc">
Non-recoverable internal error IRQ Numbe. </td></tr>
<tr><td class="fieldtype">
<a id="a5b9ea9a0c7e528e57c66d5b3cc85e674"></a>IRQn_Type</td>
<td class="fieldname">
terr_irq</td>
<td class="fielddoc">
Transfer Error IRQ Number. </td></tr>
<tr><td class="fieldtype">
<a id="a2e4966e32402d1d0a865f1a29ea2b980"></a>IRQn_Type</td>
<td class="fieldname">
abort_irq</td>
<td class="fielddoc">
Transfer Abort IRQ Number. </td></tr>
<tr><td class="fieldtype">
<a id="afc989f369398b733654a708929df5f04"></a>IRQn_Type</td>
<td class="fieldname">
wu_irq</td>
<td class="fielddoc">
Wake-up IRQ Number. </td></tr>
<tr><td class="fieldtype">
<a id="a6e93301fd2a08032aabf92fc72a196cb"></a>uint8_t</td>
<td class="fieldname">
ipl</td>
<td class="fielddoc">
Interrupt Priority for Resp, Rx, Tx, and RCV IRQs. </td></tr>
<tr><td class="fieldtype">
<a id="afe8dc047bbc3484b976553478e8f1f53"></a>uint8_t</td>
<td class="fieldname">
eei_ipl</td>
<td class="fielddoc">
Error and Event Interrupt Priority. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga613539c3294eadbba8386934530c042d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga613539c3294eadbba8386934530c042d">&#9670;&nbsp;</a></span>I3C_B_ERROR_RECOVERY_VERSION_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I3C_B_ERROR_RECOVERY_VERSION_1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support error recovery procedure for chip version 1. </p>
<p>There are two different versions of the RA2E2 MCU and the error recovery procedure is different for each version. </p>

</div>
</div>
<a id="ga394142d1aa7177899d19d06d6fae6f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga394142d1aa7177899d19d06d6fae6f89">&#9670;&nbsp;</a></span>I3C_B_DEVICE_INDEX_EXTENDED_DEVICE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I3C_B_DEVICE_INDEX_EXTENDED_DEVICE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index for selecting the device defined in the extended address table. </p>

</div>
</div>
<a id="ga66e705cb2af31c57eacd0492b2417145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66e705cb2af31c57eacd0492b2417145">&#9670;&nbsp;</a></span>I3C_B_EVENT_STATUS_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I3C_B_EVENT_STATUS_SUCCESS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The transfer was completed as expected. </p>
<p>Event Status Provided by the callback. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac8fb0ec859c44282b8323eb13de6ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8fb0ec859c44282b8323eb13de6ad3c">&#9670;&nbsp;</a></span>i3c_b_bitrate_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i3_c___b.html#gac8fb0ec859c44282b8323eb13de6ad3c">i3c_b_bitrate_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bitrate settings that can be selected at run-time using <a class="el" href="group___i3_c___a_p_i.html#a1e24e768130b9ea12f10743ff3143fa7">i3c_api_t::deviceSelect</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac8fb0ec859c44282b8323eb13de6ad3caf4dc5a9d144776169e8a4d7f21a93b84"></a>I3C_B_BITRATE_MODE_I2C_STDBR&#160;</td><td class="fielddoc"><p>Use the period settings defined in STDBRH/L. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8fb0ec859c44282b8323eb13de6ad3ca1ea841b113c1fcc83d7caae57f91c266"></a>I3C_B_BITRATE_MODE_I2C_EXTBR&#160;</td><td class="fielddoc"><p>Use the period settings defined in EXTBRH/L. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8fb0ec859c44282b8323eb13de6ad3ca30e9d9ea007ba5c667387f1198721ff9"></a>I3C_B_BITRATE_MODE_I3C_SDR0_STDBR&#160;</td><td class="fielddoc"><p>Use the period settings defined in STDBRH/L (I3C Devices only). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8fb0ec859c44282b8323eb13de6ad3ca1a146a0c77e2b1aa523548e8464efbb4"></a>I3C_B_BITRATE_MODE_I3C_SDR1_EXTBR&#160;</td><td class="fielddoc"><p>Use the period settings defined in EXTBRH/L (I3C Devices only). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8fb0ec859c44282b8323eb13de6ad3ca2fc162047690642b1e930dcef91cfb81"></a>I3C_B_BITRATE_MODE_I3C_SDR2_STDBR_X2&#160;</td><td class="fielddoc"><p>Use the period settings defined in STDBRH/L x 2 (I3C Devices only). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8fb0ec859c44282b8323eb13de6ad3caa5bb8590bfb9b8865b9cf64576ceadde"></a>I3C_B_BITRATE_MODE_I3C_SDR3_EXTBR_X2&#160;</td><td class="fielddoc"><p>Use the period settings defined in EXTBRH/L x 2 (I3C Devices only). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8fb0ec859c44282b8323eb13de6ad3ca6643480973dab04e2eba54bc434222d5"></a>I3C_B_BITRATE_MODE_I3C_SDR4_EXTBR_X4&#160;</td><td class="fielddoc"><p>Use the period settings defined in EXTBRH/L x 4 (I3C Devices only). </p>
</td></tr>
</table>

</div>
</div>
<a id="gab3ffca78d7da057f277bfd8ce2ef2e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ffca78d7da057f277bfd8ce2ef2e1a">&#9670;&nbsp;</a></span>i3c_b_activity_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i3_c___b.html#gab3ffca78d7da057f277bfd8ce2ef2e1a">i3c_b_activity_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supported activity states for ENTASn Command (See ENTASn in the MIPI I3C Specification v1.0). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab3ffca78d7da057f277bfd8ce2ef2e1aa9641d3bd84b3734620800d3242a048e1"></a>I3C_B_ACTIVITY_STATE_ENTAS0&#160;</td><td class="fielddoc"><p>Activity Interval (1 microsecond). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab3ffca78d7da057f277bfd8ce2ef2e1aa313dcdfbf6c9106d85551b78fdc89c69"></a>I3C_B_ACTIVITY_STATE_ENTAS1&#160;</td><td class="fielddoc"><p>Activity Interval (100 microseconds). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab3ffca78d7da057f277bfd8ce2ef2e1aa99e55224a2b5aff9072df1a13157b83a"></a>I3C_B_ACTIVITY_STATE_ENTAS2&#160;</td><td class="fielddoc"><p>Activity Interval (2 milliseconds). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab3ffca78d7da057f277bfd8ce2ef2e1aaf6a3aacfe021bf6de8af4de066e3c768"></a>I3C_B_ACTIVITY_STATE_ENTAS3&#160;</td><td class="fielddoc"><p>Activity Interval (50 milliseconds). </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa100c24dc68792009da85deed2f6387a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa100c24dc68792009da85deed2f6387a">&#9670;&nbsp;</a></span>i3c_b_data_rate_setting_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i3_c___b.html#gaa100c24dc68792009da85deed2f6387a">i3c_b_data_rate_setting_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum Sustained Data Rate for non-CCC messages sent by Master Device to Slave Device (See GETMXDS in the MIPI I3C Specification v1.0). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa100c24dc68792009da85deed2f6387aa5c4464e2154d923a7dbcf46a52486f9f"></a>I3C_B_DATA_RATE_SETTING_FSCL_MAX&#160;</td><td class="fielddoc"><p>There is no data rate limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa100c24dc68792009da85deed2f6387aa9193b4d9e54c0c7c9f1e046c39795ea6"></a>I3C_B_DATA_RATE_SETTING_8MHZ&#160;</td><td class="fielddoc"><p>The max sustained data rate is 8 Mhz. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa100c24dc68792009da85deed2f6387aa2039c607365d844eb591d5a95ae2f932"></a>I3C_B_DATA_RATE_SETTING_6MHZ&#160;</td><td class="fielddoc"><p>The max sustained data rate is 6 Mhz. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa100c24dc68792009da85deed2f6387aa63e2f583c75a7225371ba173ce4c7c6a"></a>I3C_B_DATA_RATE_SETTING_4MHZ&#160;</td><td class="fielddoc"><p>The max sustained data rate is 4 Mhz. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa100c24dc68792009da85deed2f6387aae74d814458aa0d31cb6503c0f144a3c6"></a>I3C_B_DATA_RATE_SETTING_2MHZ&#160;</td><td class="fielddoc"><p>The max sustained data rate is 2 Mhz. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3289540419912324ce02f19ed6a972ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3289540419912324ce02f19ed6a972ca">&#9670;&nbsp;</a></span>i3c_b_clock_data_turnaround_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i3_c___b.html#ga3289540419912324ce02f19ed6a972ca">i3c_b_clock_data_turnaround_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock to Data Turnaround Time (See GETMXDS in the MIPI I3C Specification v1.0). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3289540419912324ce02f19ed6a972caa5d48558b7227efb68f158286ead5a083"></a>I3C_B_CLOCK_DATA_TURNAROUND_8NS&#160;</td><td class="fielddoc"><p>Clock to turnaround time is 8 nanoseconds or less. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3289540419912324ce02f19ed6a972caae7c84e04abd9a4d740b89bd866b05064"></a>I3C_B_CLOCK_DATA_TURNAROUND_9NS&#160;</td><td class="fielddoc"><p>Clock to turnaround time is 9 nanoseconds or less. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3289540419912324ce02f19ed6a972caa85d3de0c20f041144cd97c7dce45191b"></a>I3C_B_CLOCK_DATA_TURNAROUND_10NS&#160;</td><td class="fielddoc"><p>Clock to turnaround time is 10 nanoseconds or less. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3289540419912324ce02f19ed6a972caab708aab348be27544293dc3cd81f144b"></a>I3C_B_CLOCK_DATA_TURNAROUND_11NS&#160;</td><td class="fielddoc"><p>Clock to turnaround time is 11 nanoseconds or less. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3289540419912324ce02f19ed6a972caa75bf3ed70a8bc727c29bf17241694e7d"></a>I3C_B_CLOCK_DATA_TURNAROUND_12NS&#160;</td><td class="fielddoc"><p>Clock to turnaround time is 12 nanoseconds or less. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3289540419912324ce02f19ed6a972caa5afb800692fec260506825c1766d5a77"></a>I3C_B_CLOCK_DATA_TURNAROUND_EXTENDED&#160;</td><td class="fielddoc"><p>Clock to turnaround time is greater than 12 nanoseconds. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa9ce3fda0950ce2aaa0cd8cf51fb5f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9ce3fda0950ce2aaa0cd8cf51fb5f95">&#9670;&nbsp;</a></span>R_I3C_B_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#structi3c__cfg__t">i3c_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an I3C_B instance. Implements <a class="el" href="group___i3_c___a_p_i.html#a963e13cc6b3cf1903a01ed87901eb6a9">i3c_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Open has already been called for this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>A selected feature is not supported with the current configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1dcb91a0152da9a6676ee27d305dceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1dcb91a0152da9a6676ee27d305dceb">&#9670;&nbsp;</a></span>R_I3C_B_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable the I3C device.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This instance is already enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07b0af405a9ca84c45aab74bd1c696c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b0af405a9ca84c45aab74bd1c696c2">&#9670;&nbsp;</a></span>R_I3C_B_DeviceCfgSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_DeviceCfgSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#structi3c__device__cfg__t">i3c_device_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_device_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the configuration for this device.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>The device cannot be a secondary master if master support is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9517cc752212a1423f0153c4330943b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9517cc752212a1423f0153c4330943b4">&#9670;&nbsp;</a></span>R_I3C_B_MasterDeviceTableSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_MasterDeviceTableSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#structi3c__device__table__cfg__t">i3c_device_table_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_device_table_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an entry in the master device table. This function is called in master mode in order to configure the devices on the I3C bus. It may also be called in slave mode when the slave receives the DEFSVLS command.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Mastership requests must be rejected is slave support is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4178234c4311d227a6fb8844e1e3a49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4178234c4311d227a6fb8844e1e3a49e">&#9670;&nbsp;</a></span>R_I3C_B_SlaveStatusSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_SlaveStatusSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#structi3c__device__status__t">i3c_device_status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the status returned to the master in response to a GETSTATUS command.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>The instance is not in slave mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Slave support is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a3f7414a893b9c2b9135523c8f6d950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a3f7414a893b9c2b9135523c8f6d950">&#9670;&nbsp;</a></span>R_I3C_B_DeviceSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_DeviceSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bitrate_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In master mode, select the device for the next transfer. This function is not used in slave mode.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This operation is prohibited in slave mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Master support is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga014e6425d49e19f05d24fd345a785589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga014e6425d49e19f05d24fd345a785589">&#9670;&nbsp;</a></span>R_I3C_B_DynamicAddressAssignmentStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_DynamicAddressAssignmentStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga6ebef50cdf52650f03e1b449325779fc">i3c_address_assignment_mode_t</a>&#160;</td>
          <td class="paramname"><em>address_assignment_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>starting_device_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the Dynamic Address Assignment Process. Implements <a class="el" href="group___i3_c___a_p_i.html#ae57d3fa9fa4a966a5c8cac38b0ea0660">i3c_api_t::dynamicAddressAssignmentStart</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL or invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This operation is prohibited in slave mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The operation could not be completed because the driver is busy. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Master support is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36ef6e15732ea09c5ad2fb19095cae4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36ef6e15732ea09c5ad2fb19095cae4e">&#9670;&nbsp;</a></span>R_I3C_B_CommandSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_CommandSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#structi3c__command__descriptor__t">i3c_command_descriptor_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_command_descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a broadcast or direct command to slave devices on the bus. Implements <a class="el" href="group___i3_c___a_p_i.html#a060147dc36cd71a01b58c30fddc11bf3">i3c_api_t::commandSend</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The operation could not be completed because the driver is busy. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This driver is not in master mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>The buffer must be aligned to 4 bytes. If it is a read operation, the length also be a multiple of 4 bytes. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Master support must be enabled to call this function. Slave support must be enabled when sending the GETACCMST command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf661fd87ee8c33efd8801d59997d4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf661fd87ee8c33efd8801d59997d4a1">&#9670;&nbsp;</a></span>R_I3C_B_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the write buffer for the transfer. In master mode, start the transfer. When the transfer is completed send a stop condition or a repeated-start. Implements <a class="el" href="group___i3_c___a_p_i.html#a0b27ccf4720531545b0c2e118032539b">i3c_api_t::write</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The operation could not be completed because the driver is busy. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This driver is disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>The buffer must be aligned to 4 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga69047e20f165f6e44fea97f3fec69399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69047e20f165f6e44fea97f3fec69399">&#9670;&nbsp;</a></span>R_I3C_B_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the read buffer for the transfer. In master mode, start the transfer. When the transfer is completed send a stop condition or a repeated-start. Implements <a class="el" href="group___i3_c___a_p_i.html#ad013ffb59c95539c84fe217b90d897ad">i3c_api_t::read</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The operation could not be completed because the driver is busy. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This driver is disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>The buffer must be aligned to 4 bytes and the length must be a multiple of 4 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b4af888ebc4c210feea2a149fd4cfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4af888ebc4c210feea2a149fd4cfc1">&#9670;&nbsp;</a></span>R_I3C_B_IbiWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_IbiWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga81ac58196d67e74a0a3702c3e760ede7">i3c_ibi_type_t</a>&#160;</td>
          <td class="paramname"><em>ibi_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiate an IBI write operation (This function is only used in slave mode).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>The operation could not be completed because the driver is busy. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function is only called in slave mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>The buffer must be aligned to 4 bytes. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Slave supoprt is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad786c546168aabcc04099f73a540af29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad786c546168aabcc04099f73a540af29">&#9670;&nbsp;</a></span>R_I3C_B_IbiRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_IbiRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the read buffer for storing received IBI data (This function is only used in master mode).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function is only called in master mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ALIGNMENT</td><td>The buffer must be aligned to 4 bytes and the length must be a multiple of 4 bytes. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Master support is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd84cf1baec319b18540a857545ab51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd84cf1baec319b18540a857545ab51b">&#9670;&nbsp;</a></span>R_I3C_B_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_I3C_B_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i3_c___a_p_i.html#ga63111d6c1096458d5059f5f6fac3f579">i3c_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the I3C instance. Implements <a class="el" href="group___i3_c___a_p_i.html#aee21d22f092a6c93976b94635642e33f">i3c_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Open successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An argument was NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>This instance has not been opened yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.0.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
