<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZG Flexible Software Package Documentation: Watchdog (r_wdt)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZG Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___w_d_t.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Watchdog (r_wdt)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___m_o_n_i_t_o_r_i_n_g___m_o_d_u_l_e_s.html">Monitoring</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff080d0dcc993cfbe7e99771396feffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaff080d0dcc993cfbe7e99771396feffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad64d0778fd0ceccb13a7287bb0d1fca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gad64d0778fd0ceccb13a7287bb0d1fca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5b9ff42df96b9fd4603dda47b946cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gacd5b9ff42df96b9fd4603dda47b946cb">R_WDT_StatusClear</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, const <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status)</td></tr>
<tr class="separator:gacd5b9ff42df96b9fd4603dda47b946cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf328598042575cbe4f126f59bbc1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga17bf328598042575cbe4f126f59bbc1b">R_WDT_StatusGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga17bf328598042575cbe4f126f59bbc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b4f726ecfe6795c7887dc1226450ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaf6b4f726ecfe6795c7887dc1226450ca">R_WDT_CounterGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, uint32_t *const p_count)</td></tr>
<tr class="separator:gaf6b4f726ecfe6795c7887dc1226450ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e98a5b526d81651da1ffeda3f70263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gac6e98a5b526d81651da1ffeda3f70263">R_WDT_TimeoutGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__timeout__values__t">wdt_timeout_values_t</a> *const p_timeout)</td></tr>
<tr class="separator:gac6e98a5b526d81651da1ffeda3f70263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602ed1a63b61c46df822059ab6a5395e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga602ed1a63b61c46df822059ab6a5395e">R_WDT_CallbackSet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_ctrl, void(*p_callback)(<a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga602ed1a63b61c46df822059ab6a5395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the WDT peripheral on RZ MPUs. This module implements the <a class="el" href="group___w_d_t___a_p_i.html">WDT Interface</a>. </p>
<h1><a class="anchor" id="r-wdt-overview"></a>
Overview</h1>
<p>The watchdog timer is used to recover from unexpected errors in an application. The watchdog timer must be refreshed periodically in the permitted count window by the application. If the count is allowed to timeout or refresh occurs outside of the valid refresh period, the WDT resets the device or generates an IRQ. Note: The support for window functions or interrupt request generation varies across devices.</p>
<div class="image">
<img src="r_wdt_operation_example.png" alt="r_wdt_operation_example.png"/>
<div class="caption">
Watchdog Timer Operation Example</div></div>
 <h2><a class="anchor" id="r-wdt-features"></a>
Features</h2>
<h3>RZ/G3S</h3>
<p>The WDT HAL module has the following key features:</p>
<ul>
<li>When the WDT timeouts twice, the following event can occur:<ul>
<li>Resetting of the device<a class="anchor" id="um_wdt_configuration_for_reset_control"></a></li>
</ul>
</li>
<li>The WDT can be started from the application.<a class="anchor" id="um_wdt_register_start_mode"></a></li>
</ul>
<h3>RZ/G3E</h3>
<ul>
<li>When the WDT timeouts or is refreshed outside of the permitted refresh window, one of the following events can occur:<ul>
<li>Resetting of the device</li>
<li>Generation of an IRQ</li>
</ul>
</li>
<li>The WDT can be started from the application.</li>
</ul>
<h1><a class="anchor" id="r-wdt-configuration"></a>
Configuration</h1>
<p>When using register start mode, configure the watchdog timer on the Stacks tab.</p>
<p><a class="anchor" id="um_wdt_nmi_callback_required"></a><a class="anchor" id="um_wdt_auto_start_mode_support"></a><a class="anchor" id="um_wdt_configuration_for_refresh_window_start_position"></a><a class="anchor" id="um_wdt_configuration_for_refresh_window_end_position"></a><a class="anchor" id="um_wdt_configuration_for_wdt_clock_division"></a><a class="anchor" id="um_wdt_configuration_for_wdt_timeout_period"></a> <h2>Build Time Configurations for r_wdt</h2>
The following build time configurations are defined in fsp_cfg/r_wdt_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Monitoring &gt; Watchdog (r_wdt)</h2>
This module can be added to the Stacks tab via New Stack &gt; Monitoring &gt; Watchdog (r_wdt).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_wdt0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; Channel</td><td>MCU Specific Options</td><td></td><td>Check the user's manual: Hardware to see which CPU a channel is for. </td></tr>
<tr>
<td>General &gt; Timeout</td><td>Value must be non-negative between 0.04369 and 178.9</td><td>60 </td><td>Select the time (in seconds) before the WDT counter timeouts. (A single timeout does not generate a reset.) </td></tr>
<tr>
<td>General &gt; Timeout</td><td>MCU Specific Options</td><td></td><td>Select the watchdog timeout in cycles. </td></tr>
<tr>
<td>General &gt; Clock Division Ratio</td><td>MCU Specific Options</td><td></td><td>Select the watchdog clock divisor. </td></tr>
<tr>
<td>General &gt; Window Start Position</td><td>MCU Specific Options</td><td></td><td>Select the allowed watchdog refresh start point in %. </td></tr>
<tr>
<td>General &gt; Window End Position</td><td>MCU Specific Options</td><td></td><td>Select the allowed watchdog refresh end point in %. </td></tr>
<tr>
<td>General &gt; WDT Counting</td><td>MCU Specific Options</td><td></td><td>Select to enable or disable WDT counting. It is recommended to set "WDT Counting" to "Disabled" to avoid unintentional WDT interrupt occurs when debugging the user program. </td></tr>
<tr>
<td>Reset Operation &gt; WDT Pin Assertion</td><td>MCU Specific Options</td><td></td><td>Select to enable or disable the pin assertion due to a request by WDT. </td></tr>
<tr>
<td>Reset Operation &gt; System Reset</td><td>MCU Specific Options</td><td></td><td>Select to enable or disable system reset due to a request by WDT. </td></tr>
<tr>
<td>Reset Operation &gt; Cold Reset</td><td>MCU Specific Options</td><td></td><td>Select to enable or disable the cold reset due to a request by WDT. </td></tr>
<tr>
<td>Interrupt &gt; Interrupt Enable</td><td>MCU Specific Options</td><td></td><td>Enable the WDT interrupt. </td></tr>
<tr>
<td>Interrupt &gt; Interrupt Priority</td><td>Value must be an integer between 0 and 255</td><td>24 </td><td>Select the interrupt priority. </td></tr>
<tr>
<td>Interrupt &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be provided. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-wdt-clock-configuration"></a>
Clock Configuration</h2>
<p>The WDT clock is based on the OSCCLK frequency. You can not set the OSCCLK frequency using the <b>Clocks</b> tab of the RZ Configuration editor or by using the CGC Interface at run-time. The below table describes the maximum timeout period on each device: </p><table class="doxtable">
<tr>
<th align="left">Device </th><th align="left">WDT clock source </th><th align="left">Maximum timeout period  </th></tr>
<tr>
<td align="left">RZ/G3S </td><td align="left">OSCCLK = 24MHz </td><td align="left">178.9 seconds (approximately ) </td></tr>
<tr>
<td align="left">RZ/G3E </td><td align="left">OSCCLK = 24MHz </td><td align="left">0.175 seconds </td></tr>
</table>
<h2><a class="anchor" id="r-wdt-pin-configuration"></a>
Pin Configuration</h2>
<p>This WDT uses the following pin. </p><table class="doxtable">
<tr>
<th align="left">Device </th><th align="left">Pin name </th><th align="left">Description  </th></tr>
<tr>
<td align="left">RZ/G3S </td><td align="left">WDTOVF_PERROUT </td><td align="left">Watchdog timer counter overflow signal output. </td></tr>
<tr>
<td align="left">RZ/G3E </td><td align="left">WDTUDF_PERROUT </td><td align="left">Watchdog timer counter underflow signal output. </td></tr>
</table>
<h1><a class="anchor" id="r-wdt-usage_notes"></a>
Usage Notes</h1>
<h2>Period Calculation</h2>
<h3>On RZ/G3S</h3>
<p>The configuration editor can directly enter the timeout period (seconds) until timeout. The selectable timeout time (seconds) is from 0.04369(s) to 178.9(s).</p>
<p>Below is an example of calculating the maximum timeout time when OSCLK is 24MHz.</p>
<p>OSCCLK = 24 MHz<br />
Timeout period = 1024 * 1024 * 4096 = 4294967296 cycles<br />
(4095 : Register Settimg Max Value)<br />
Cycle time = 1 / 24 MHz = 41.66 ns<br />
Timeout = 41.66 us x 4294967296 cycles = 178.9 seconds </p><h3>On RZ/G3E</h3>
<p>The WDT operates from OSCCLK. With a OSCCLK of 24 MHz, the maximum time from the last refresh to device reset or IRQ generation will be just over 0.175 seconds as detailed below.</p>
<p>OSCCLK = 24 MHz<br />
Clock division ratio = OSCCLK / 256<br />
Timeout period = 16384 cycles<br />
WDT clock frequency = 24 MHz / 256 = 93.750 kHz<br />
Cycle time = 1 / 93.750 kHz = 10.667 us<br />
Timeout = 10.667 us x 16384 cycles = 0.175 seconds</p>
<h2><a class="anchor" id="r-wdt-limitations"></a>
Limitations</h2>
<h3>On RZ/G3S</h3>
<ul>
<li>When using a debugger, if a system reset by WDT occured, the connection will be lost. In this case, terminate the current debug session and start a new one.</li>
</ul>
<h3>On RZ/G3E</h3>
<p>Developers should be aware of the following limitations when using the WDT:</p><ul>
<li>If the WDT is configured to stop the counter in low power mode, then your application must restart the watchdog by calling <a class="el" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh()</a> after the MPU wakes from low power mode.</li>
<li>When WDT counting starts, it keeps running even if the user program is stopped at a breakpoint by the debugger. Then an unintentional WDT interrupt occurs. To avoid such cases, it is recommended to set "WDT Counting" to "Disabled" when debugging.</li>
</ul>
<h2>WDT Interrupt</h2>
<p>WDT interrupt to CPU are prohibited in specific core.</p>
<table class="doxtable">
<tr>
<th>Device</th><th>Core </th><th>WDT interrupt to CPU  </th></tr>
<tr>
<td>RZ/G3S</td><td>CM33 </td><td>Not prohibited </td></tr>
<tr>
<td>RZ/G3E</td><td>CM33 </td><td>Prohibited </td></tr>
</table>
<h1><a class="anchor" id="r-wdt-examples"></a>
Examples</h1>
<h2>WDT Basic Example</h2>
<p>This is a basic example of minimal use of the WDT in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> wdt_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a>(&amp;g_wdt_ctrl, &amp;g_wdt_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Call R_WDT_Refresh to start the watchdog. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter timeouts. */</span></div><div class="line">        err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>WDT Advanced Example</h2>
<h3>RZ/G3S</h3>
<p>This example demonstrates using a start window and gives an example callback to handle an interrupt generated by a timeout. </p><div class="fragment"><div class="line"><span class="preprocessor"> #define WDT_START_WINDOW_75    ((1024 * 1024 * WDT_COUNT_CYCLE_VALUE) * 3 / 4 - 1)</span></div><div class="line"></div><div class="line"><span class="comment">/* Example callback called when a watchdog NMI occurs. */</span></div><div class="line"><span class="keywordtype">void</span> wdt_callback (<a class="code" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_args);</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___w_d_t.html#ga17bf328598042575cbe4f126f59bbc1b">R_WDT_StatusGet</a>(&amp;g_wdt_ctrl, &amp;status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gacd5b9ff42df96b9fd4603dda47b946cb">R_WDT_StatusClear</a>(&amp;g_wdt_ctrl, status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Call R_WDT_Refresh() to continue using the watchdog after an error. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> wdt_advanced_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Check if the WDTOVF flag is set to know if the system is</span></div><div class="line"><span class="comment">     * recovering from a WDT reset. */</span></div><div class="line">    <span class="keywordflow">if</span> (R_CPG-&gt;CPG_WDTOVF_RST_b.WDTOVF1)</div><div class="line">    {</div><div class="line">        R_CPG-&gt;CPG_WDTOVF_RST = R_CPG_CPG_WDTOVF_RST_WDTOVF1_Msk | R_CPG_CPG_WDTOVF_RST_WDTOVF1_WEN_Msk;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable system reset due to WDT. */</span></div><div class="line">    <a class="code" href="group___w_d_t.html#structwdt__extended__cfg__t">wdt_extended_cfg_t</a> g_wdt_cfg_extend_0 =</div><div class="line">    {</div><div class="line">        .channel                  = 1,</div><div class="line">        .wdt_counting_enable      = <span class="keyword">true</span>,</div><div class="line">        .system_reset_enable      = <span class="keyword">true</span>,</div><div class="line">        .wdt_pin_assertion_enable = <span class="keyword">false</span>,</div><div class="line">        .cold_reset_enable        = <span class="keyword">false</span>,</div><div class="line">        .timeout_ipl              = 24,</div><div class="line">        .timeout_irq              = WDT1_WDTINT_IRQn,</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> g_wdt_cfg_0 =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___w_d_t___a_p_i.html#a32ddaf9b3fd7bab2b654e660588ac680">timeout</a>        = <a class="code" href="group___w_d_t___a_p_i.html#gga880fcf63a5220c6618a0cf380268a76cacd016302c00b39880d3828d18467833e">WDT_TIMEOUT_16384</a>,</div><div class="line">        .clock_division = <a class="code" href="group___w_d_t___a_p_i.html#gga6b0f563a6311763e6204add68a018089a379cad22ab77f5b144788ae4fb82e7af">WDT_CLOCK_DIVISION_8192</a>,</div><div class="line">        .window_start   = <a class="code" href="group___w_d_t___a_p_i.html#gga9e0c1284f5d75d4a090d988536e3f633a8677bab323b9b04737bf003bc8c68703">WDT_WINDOW_START_100</a>,</div><div class="line">        .window_end     = <a class="code" href="group___w_d_t___a_p_i.html#gga62d4360afabd1652aa7a1b9f624d7f61ad9fd7f9a41a89a9d67f0b8c37cbfdc12">WDT_WINDOW_END_0</a>,</div><div class="line">        .reset_control  = <a class="code" href="group___w_d_t___a_p_i.html#gga7624d80dde311cb1289f558ea464fa63a9025ac51aeed3fac87e3733965b06215">WDT_RESET_CONTROL_NMI</a>,</div><div class="line">        .stop_control   = <a class="code" href="group___w_d_t___a_p_i.html#gga803dd68cafce3a3d9ca5630b8c4838daac3a7223139a46596bf979e607c7c26f2">WDT_STOP_CONTROL_DISABLE</a>,</div><div class="line">        .p_callback     = NULL,</div><div class="line">        .p_context      = NULL,</div><div class="line">        .p_extend       = &amp;g_wdt_cfg_extend_0,</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Open the module. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a>(&amp;g_wdt_ctrl, &amp;g_wdt_cfg_0);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize other application code. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Call R_WDT_Refresh() to start the WDT. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line">        <span class="comment">/* (Optional) If there is a chance the application takes less time than</span></div><div class="line"><span class="comment">         * the start window, verify the WDT counter is past the start window</span></div><div class="line"><span class="comment">         * before refreshing the WDT. */</span></div><div class="line">        uint32_t wdt_counter = 0U;</div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line"></div><div class="line">            <span class="comment">/* Read the current WDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___w_d_t.html#gaf6b4f726ecfe6795c7887dc1226450ca">R_WDT_CounterGet</a>(&amp;g_wdt_ctrl, &amp;wdt_counter);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        } <span class="keywordflow">while</span> (wdt_counter &lt;= WDT_START_WINDOW_75);</div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter timeouts to prevent reset. */</span></div><div class="line">        err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h3>RZ/G3E</h3>
<p>This example demonstrates using a start window and gives an example callback to handle an IRQ generated by a timeout or refresh error.</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #define WDT_TIMEOUT_COUNTS     (16384U)</span></div><div class="line"><span class="preprocessor"> #define WDT_MAX_COUNTER        (WDT_TIMEOUT_COUNTS - 1U)</span></div><div class="line"><span class="preprocessor"> #define WDT_START_WINDOW_75    ((WDT_MAX_COUNTER * 3) / 4)</span></div><div class="line"></div><div class="line"><span class="comment">/* Example callback called when a watchdog NMI occurs. */</span></div><div class="line"><span class="keywordtype">void</span> wdt_callback (<a class="code" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_args);</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___w_d_t.html#ga17bf328598042575cbe4f126f59bbc1b">R_WDT_StatusGet</a>(&amp;g_wdt_ctrl, &amp;status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Log source of NMI and any other debug information. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gacd5b9ff42df96b9fd4603dda47b946cb">R_WDT_StatusClear</a>(&amp;g_wdt_ctrl, status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Call R_WDT_Refresh() to continue using the watchdog after an error. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> wdt_advanced_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable system reset due to WDT. */</span></div><div class="line">    <a class="code" href="group___w_d_t.html#structwdt__extended__cfg__t">wdt_extended_cfg_t</a> g_wdt_cfg_extend_0 =</div><div class="line">    {</div><div class="line">        .channel                  = 0,</div><div class="line">        .wdt_counting_enable      = <span class="keyword">true</span>,</div><div class="line">        .system_reset_enable      = <span class="keyword">true</span>,</div><div class="line">        .wdt_pin_assertion_enable = <span class="keyword">false</span>,</div><div class="line">        .cold_reset_enable        = <span class="keyword">false</span>,</div><div class="line">        .timeout_ipl              = 8,</div><div class="line">        .timeout_irq              = <a class="code" href="group___b_s_p___m_c_u.html#ga4e36b09bee515ff1b813e7ba0412e60d">FSP_INVALID_VECTOR</a>,</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> g_wdt_cfg_0 =</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___w_d_t___a_p_i.html#a32ddaf9b3fd7bab2b654e660588ac680">timeout</a>        = <a class="code" href="group___w_d_t___a_p_i.html#gga880fcf63a5220c6618a0cf380268a76cacd016302c00b39880d3828d18467833e">WDT_TIMEOUT_16384</a>,</div><div class="line">        .clock_division = <a class="code" href="group___w_d_t___a_p_i.html#gga6b0f563a6311763e6204add68a018089a85b86587793408cd7b12fc4eb18e93c0">WDT_CLOCK_DIVISION_256</a>,</div><div class="line">        .window_start   = <a class="code" href="group___w_d_t___a_p_i.html#gga9e0c1284f5d75d4a090d988536e3f633a8677bab323b9b04737bf003bc8c68703">WDT_WINDOW_START_100</a>,</div><div class="line">        .window_end     = <a class="code" href="group___w_d_t___a_p_i.html#gga62d4360afabd1652aa7a1b9f624d7f61ad9fd7f9a41a89a9d67f0b8c37cbfdc12">WDT_WINDOW_END_0</a>,</div><div class="line">        .reset_control  = <a class="code" href="group___w_d_t___a_p_i.html#gga7624d80dde311cb1289f558ea464fa63a9025ac51aeed3fac87e3733965b06215">WDT_RESET_CONTROL_NMI</a>,</div><div class="line">        .stop_control   = <a class="code" href="group___w_d_t___a_p_i.html#gga803dd68cafce3a3d9ca5630b8c4838daac3a7223139a46596bf979e607c7c26f2">WDT_STOP_CONTROL_DISABLE</a>,</div><div class="line">        .p_callback     = NULL,</div><div class="line">        .p_context      = NULL,</div><div class="line">        .p_extend       = &amp;g_wdt_cfg_extend_0,</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Check if the error system reset flag for WDT is set to know if the system is</span></div><div class="line"><span class="comment">     * recovering from a WDT reset. */</span></div><div class="line">    <span class="keywordflow">if</span> (R_CPG-&gt;CPG_ERROR_RST2 &amp; R_CPG_CPG_ERROR_RST2_ERROR_RST0_Msk)</div><div class="line">    {</div><div class="line">        R_CPG-&gt;CPG_ERROR_RST2 = R_CPG_CPG_ERROR_RST2_ERROR_RST0_Msk | R_CPG_CPG_ERROR_RST2_ERROR_RST0_WEN_Msk;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the module. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a>(&amp;g_wdt_ctrl, &amp;g_wdt_cfg_0);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize other application code. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* (Register start mode) Call R_WDT_Refresh() to start the WDT in register</span></div><div class="line"><span class="comment">     * start mode.  Do not call R_WDT_Refresh() in auto start mode unless the</span></div><div class="line"><span class="comment">     * counter is in the acceptable refresh window. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line">        <span class="comment">/* (Optional) If there is a chance the application takes less time than</span></div><div class="line"><span class="comment">         * the start window, verify the WDT counter is past the start window</span></div><div class="line"><span class="comment">         * before refreshing the WDT. */</span></div><div class="line">        uint32_t wdt_counter = 0U;</div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Read the current WDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___w_d_t.html#gaf6b4f726ecfe6795c7887dc1226450ca">R_WDT_CounterGet</a>(&amp;g_wdt_ctrl, &amp;wdt_counter);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line">        } <span class="keywordflow">while</span> (wdt_counter &gt;= WDT_START_WINDOW_75);</div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter timeouts to prevent reset or NMI. */</span></div><div class="line">        err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structwdt__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#structwdt__instance__ctrl__t">wdt_instance_ctrl_t</a></td></tr>
<tr class="separator:structwdt__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwdt__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#structwdt__extended__cfg__t">wdt_extended_cfg_t</a></td></tr>
<tr class="separator:structwdt__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structwdt__instance__ctrl__t" id="structwdt__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwdt__instance__ctrl__t">&#9670;&nbsp;</a></span>wdt_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wdt_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>WDT private control block. DO NOT MODIFY. Initialization occurs when <a class="el" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open()</a> is called. </p>
</div>
</div>
</div>
<a name="structwdt__extended__cfg__t" id="structwdt__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwdt__extended__cfg__t">&#9670;&nbsp;</a></span>wdt_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wdt_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>WDT configuration extension. This extension is required. </p>
</div>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaff080d0dcc993cfbe7e99771396feffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff080d0dcc993cfbe7e99771396feffb">&#9670;&nbsp;</a></span>R_WDT_Refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_Refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refresh the watchdog timer. Implements <a class="el" href="group___w_d_t___a_p_i.html#a0d1533024396b8280b7240c781a09a44">wdt_api_t::refresh</a>.</p>
<p>In addition to refreshing the watchdog counter this function can be used to start the counter in register start mode.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter timeouts. */</span></div><div class="line">        err = <a class="code" href="group___w_d_t.html#gaff080d0dcc993cfbe7e99771396feffb">R_WDT_Refresh</a>(&amp;g_wdt_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT successfully refreshed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad64d0778fd0ceccb13a7287bb0d1fca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad64d0778fd0ceccb13a7287bb0d1fca8">&#9670;&nbsp;</a></span>R_WDT_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the WDT driver based on the input configurations. This function sets the callback function, the timeout count value, and enables the timeout interrupt. Implements <a class="el" href="group___w_d_t___a_p_i.html#af03fc1703319e1adacabc412c7e3de31">wdt_api_t::open</a>.</p>
<p>This function should only be called once as WDT configuration registers can only be written to once so subsequent calls will have no effect.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gad64d0778fd0ceccb13a7287bb0d1fca8">R_WDT_Open</a>(&amp;g_wdt_ctrl, &amp;g_wdt_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer, or one or more configuration options is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. This module can only be opened once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd5b9ff42df96b9fd4603dda47b946cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5b9ff42df96b9fd4603dda47b946cb">&#9670;&nbsp;</a></span>R_WDT_StatusClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_StatusClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the WDT status and error flags. Implements <a class="el" href="group___w_d_t___a_p_i.html#af66d798489c7ace801fee8b5a9c833c2">wdt_api_t::statusClear</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___w_d_t.html#gacd5b9ff42df96b9fd4603dda47b946cb">R_WDT_StatusClear</a>(&amp;g_wdt_ctrl, status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT flag(s) successfully cleared. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17bf328598042575cbe4f126f59bbc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17bf328598042575cbe4f126f59bbc1b">&#9670;&nbsp;</a></span>R_WDT_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the WDT status flags. Implements <a class="el" href="group___w_d_t___a_p_i.html#a317b972273cef3bc94087727b3ee17c5">wdt_api_t::statusGet</a>.</p>
<p>Indicates both status and error conditions.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___w_d_t.html#ga17bf328598042575cbe4f126f59bbc1b">R_WDT_StatusGet</a>(&amp;g_wdt_ctrl, &amp;status);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT status successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6b4f726ecfe6795c7887dc1226450ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b4f726ecfe6795c7887dc1226450ca">&#9670;&nbsp;</a></span>R_WDT_CounterGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_CounterGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the current count value of the WDT. Implements <a class="el" href="group___w_d_t___a_p_i.html#a724c02d7265d5eaa846cf97a3556f5d6">wdt_api_t::counterGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">            <span class="comment">/* Read the current WDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___w_d_t.html#gaf6b4f726ecfe6795c7887dc1226450ca">R_WDT_CounterGet</a>(&amp;g_wdt_ctrl, &amp;wdt_counter);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT current count successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6e98a5b526d81651da1ffeda3f70263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e98a5b526d81651da1ffeda3f70263">&#9670;&nbsp;</a></span>R_WDT_TimeoutGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_TimeoutGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__timeout__values__t">wdt_timeout_values_t</a> *const&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read timeout information for the watchdog timer. Implements <a class="el" href="group___w_d_t___a_p_i.html#ac2b6d848e8be0ff1a0a1be43289ad925">wdt_api_t::timeoutGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>WDT timeout information retrieved successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null Pointer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Instance control block is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga602ed1a63b61c46df822059ab6a5395e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga602ed1a63b61c46df822059ab6a5395e">&#9670;&nbsp;</a></span>R_WDT_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_WDT_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___w_d_t___a_p_i.html#a0237b5cdf9261e1b80bc085b3a6e5583">wdt_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.0.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
